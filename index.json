[{"categories":["Proiecte"],"content":"Ãn acest articol, vom pune Ã®n discuÈ›ie contruirea È™i animarea evolventei unui cerc, curba care se obÈ›ine prin desfÄƒÈ™urarea imaginarÄƒ de pe mosor sau Ã®nfÄƒÈ™urarea pe mosor a unei aÈ›e cu condiÈ›ia È›inerii acesteia permanent Ã®ntinsÄƒ.","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea È™i animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"1. Introducere Salutare tuturor! ğŸ™‹â€â™‚ï¸ Ãn acest articol vom pune Ã®n discuÈ›ie construirea È™i animarea evolventei unui cerc. Evolventa, vorbind cu un limbaj simplu, este o curbÄƒ care se obÈ›ine prin desfÄƒÈ™urarea imaginarÄƒ de pe mosor sau Ã®nfÄƒÈ™urarea pe mosor a unei aÈ›e cu condiÈ›ia È›inerii acesteia permanent Ã®ntinsÄƒ. Evolventa este parte a profilului dintelui unei roÈ›i dinÈ›ate folosite la transmisii prin angrenaje. Profilul evolventic asigurÄƒ un raport de transmitere constant Ã®ntre roÈ›ile dinÈ›ate, randament ridicat, precum È™i alte avantaje. Raportul de transmitere constat Ã®ntre 2 roÈ›i dinÈ›ate cu profil evolventic. Credits: Wikipedia Proiectarea evolventei o vom realiza cu ajutorul LaTeX, sistemul de preparare a documentelor ce se foloseÈ™te pe larg Ã®n mediul academic. Demonstrare graficÄƒ cum evolventa funcÈ›ioneazÄƒ. $\\LaTeX$ este bine cunoscut pentru abilitatea sa de lucru cu texte matematice, È™tiinÈ›ifice È™i alte lucrÄƒri complexe: documente lungi sau complicate, precum È™i cele multilingve. Sistemele $\\TeX$ produc rezultatul pe hÃ¢rtie sau pe ecranul computerului cu cea mai Ã®naltÄƒ calitate tipograficÄƒ. AceastÄƒ calitate este crucialÄƒ pentru textele complexe, unde capacitatea cititorului de a Ã®nÈ›elege materialul depinde de claritatea cu care acesta este prezentat 1. Codul complet al proiectÄƒrii evolventei unui cerc Ã®l gÄƒsiÈ›i mai jos sau pe repository-ul Github. Ãn continuare vom explica mai detaliat utilitatea fiecÄƒrei secÈ›iuni de cod. \\documentclass[tikz,border=10pt]{standalone} \\usepackage{pgfplots,amsmath} \\pgfplotsset{compat=newest} \\begin{document} \\pgfmathsetmacro\\radius{2} % Colors \\definecolor{tangentLineColor}{HTML}{BC5090} \\definecolor{remainingArcColor}{HTML}{003F5C} \\definecolor{involuteSplineColor}{HTML}{58508D} \\definecolor{accentColor}{HTML}{FF6361} \\colorlet{dashedLineColor}{black} % Styles \\tikzstyle{information text}=[fill=red!10,inner sep=1ex] \\pgfplotsset{ /pgf/number format/textnumber/.style={ fixed, fixed zerofill, precision=2, 1000 sep={,}, }, } \\foreach \\rollAngle in {0.05,0.1,...,3.25} { \\begin{tikzpicture} [ point/.style = {draw, circle, fill = black, inner sep = 1pt}, dot/.style = {draw, circle, fill = black, inner sep = .2pt}, declare function = { involutex(\\radius,\\psi) = \\radius * (cos(\\psi) + \\psi * sin(\\psi)); involutey(\\radius,\\psi) = \\radius * (sin(\\psi) - \\psi * cos(\\psi)); arcx(\\radius,\\a,\\psi) = \\a + \\radius * cos(\\psi); arcy(\\radius,\\b,\\psi) = \\b + \\radius * sin(\\psi); }, ] \\pgfmathsetmacro\\rollAngleDeg{deg(\\rollAngle)} \\pgfmathsetmacro\\arcLength{0.5 * \\rollAngle * \\radius^2} \\pgfmathsetmacro\\curvature{1 / (\\radius * \\rollAngle)} \\begin{axis}[ name=plotAxis, trig format=rad, axis equal, axis lines=center, grid=both, xlabel=$x$, ylabel=$y$, xmin=-5,xmax=5, ymin=-3,ymax=7, xticklabels=\\empty, yticklabels=\\empty, ] \\coordinate (O) at (0,0); \\coordinate (Or) at (\\radius,0); \\coordinate (L1) at ({arcx(\\radius,0,\\rollAngle)},{arcy(\\radius,0,\\rollAngle)}); \\coordinate (L2) at ({involutex(\\radius,\\rollAngle)},{involutey(\\radius,\\rollAngle)}); \\addplot [domain=2*pi:\\rollAngle,samples=200,remainingArcColor,thick,line cap=round]({arcx(\\radius,0,x)},{arcy(\\radius,0,x)}); \\addplot [domain=0:\\rollAngle,samples=200,dashedLineColor,dashed,line cap=round]({arcx(\\radius,0,x)},{arcy(\\radius,0,x)}); \\addplot [domain=0.01:\\rollAngle,samples=200,involuteSplineColor,thick,line cap=round]({involutex(\\radius,x)},{involutey(\\radius,x)}); \\draw[tangentLineColor,thick] (L1) -- (L2); \\draw[dashedLineColor,dashed] (O) -- (L1) node [accentColor,pos=0.5,sloped,above] {$r$}; \\addplot [domain=0:\\rollAngle,samples=200,accentColor,line cap=round]({arcx(.4,0,x)},{arcy(.4,0,x)}) node[] at (.5, -.3) {$\\psi$}; \\end{axis} \\node [xshift=.5cm,below right,align=center,text width=6cm,style=information text] at (plotAxis.north east) { This is a demonstration how the {\\color{accentColor} involute of a circle} works. So, {\\color{accentColor} $r$} is radius of the circle, {\\color{accentColor} $\\psi$} --- roll angle, {\\color{accentColor} $L$} --- ar","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:1:0","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea È™i animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"2. Setarea mediului de dezvoltare Pentru development, vom folosi aplicaÈ›ia gratuitÄƒ Visual Studio Code Ã®n calitate de editor de cod sursÄƒ È™i vom crea container Docker, Ã®n interiorul cÄƒruia vom instala È™i configura toate pachetele necesare pentru lucru. Cu ajutorul editorului Visual Studio Code putem sÄƒ facem development chiar Ã®n interiorul containerului ğŸ’¡. Cum se configureazÄƒ devcontainers puteÈ›i citi Ã®n acest articol. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:2:0","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea È™i animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"2.1. Configurarea Dockerfile Docker poate construi Ã®n mod automat imagini citind instrucÈ›iunile dintr-un fiÈ™ier Dockerfile. Un fiÈ™ier Dockerfile este un document text care conÈ›ine toate comenzile pe care un utilizator le-ar putea apela din linia de comandÄƒ pentru a asambla o imagine 2. Ãn scopul efectuÄƒrii development-ului, vom folosi imaginea de bazÄƒ blang/latex. Acesta va instala, compila È™i configura LaTeX. Astfel, vom avea toate pachetele LaTeX instalate Ã®n devcontainer-ul nostru. Acest fiÈ™ier Ã®l vom plasa Ã®n mapa .devcontainer din proiectul nostru. FROM blang/latex:ubuntu RUN apt update \u0026\u0026 apt install -y graphicsmagick ffmpeg Pe lÃ¢ngÄƒ LaTeX, vom mai instala douÄƒ pachete adiÈ›ionale care se numesc GraphicsMagick È™i FFmpeg. Acestea vor servi la convertirea fiÈ™ierului de ieÈ™ire pdf, generat de LaTex, Ã®n fiÈ™ier mp4. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:2:1","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea È™i animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"2.2. Configurarea devcontainer.json La aceastÄƒ etapÄƒ, vom crea fiÈ™ierul devcontainer.json care la fel Ã®l vom plasa Ã®n mapa .devcontainer din proiect. Acest fiÈ™ier este utilizat pentru pentru lansarea (sau ataÈ™area) containerului de dezvoltare (devcontainer). Acest fiÈ™ier va conÈ›ine È™i comanda pentru instalarea in VS Code a extensiei LaTeX Workshop, care are ca funcÈ›ionalitate completarea automatÄƒ a codului, syntax highliting, compilarea documentului È™i multe alte funcÈ›ionalitÄƒÈ›i. { \"name\": \"LaTeX\", \"dockerFile\": \"Dockerfile\", \"settings\": { \"terminal.integrated.shell.linux\": \"/bin/bash\", \"latex-workshop.latex.watch.usePolling\": true, \"latex-workshop.latex.autoBuild.run\": \"onFileChange\", \"latex-workshop.latex.autoBuild.interval\": 1000, \"latex-workshop.docker.enabled\": false, }, \"extensions\": [ \"james-yu.latex-workshop\", \"adam-bender.commit-message-editor\" ], \"mounts\": [ ], \"remoteEnv\": { } } DacÄƒ au fost efectuate configurÄƒrile corecte, atunci la pornirea aplicaÈ›iei VS Code È™i la deschiderea mapei cu proiectul dat, editorul ne va propune sÄƒ trecem pe devcontainer. Visual Studio Code propune de a deschide mapa Ã®n container. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:2:2","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea È™i animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"3. Structura de bazÄƒ È™i preambulul documentului LaTeX Pentru Ã®nceput este necesar de a crea un fiÈ™ier cu extensia .tex. Toate instrucÈ›iunile necesare pentru construirea evolventei vor fi scrise Ã®n acesta. CÃ¢nd $\\LaTeX$ proceseazÄƒ un document, el se aÈ™teaptÄƒ ca documentul sÄƒ conÈ›inÄƒ o anumitÄƒ structurÄƒ. Astfel, fiecare document trebuie sÄƒ conÈ›inÄƒ comenzile: \\documentclass{...} \\begin{document} ... \\end{document} Ãntre comenzile \\documentclass È™i \\begin{document} se afla aÈ™a numitul preambul. Ãn secÈ›iunea datÄƒ se conÈ›in comenzile care vor afecta Ã®ntregul document LaTeX. Tot aici se importÄƒ pachetele necesare È™i se efectueazÄƒ careva setÄƒri asupra acestora. Ãn cazul nostru, comanda \\documentclass mai conÈ›ine cÃ¢teva opÈ›iuni, izolate Ã®ntre paranteze pÄƒtrate È™i mai specificÄƒ ce tip de clasÄƒ a documentului se va folosi, aceasta fiind izolatÄƒ Ã®ntre acolade. \\documentclass[tikz,border=10pt]{standalone} ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:3:0","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea È™i animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"3.1. Clasa È™i pachetul standalone Clasa standalone este proiectatÄƒ pentru a crea fragmente individuale de conÈ›inut. AceastÄƒ clasÄƒ este utilÄƒ la generarea imaginilor care vor fi incluse Ã®n alte documente 3. Pachetul standalone permite utilizatorilor sÄƒ plaseze cu uÈ™urinÈ›Äƒ imagini sau alt material Ã®n fiÈ™ierele proprii È™i sÄƒ le compileze de sine stÄƒtÄƒtor sau ca parte a unui document principal 4. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:3:1","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea È™i animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"3.2. OpÈ›iunea È™i pachetul TikZ Pachetul TikZ este probabil cel mai complex È™i puternic instrument pentru crearea elementelor grafice Ã®n LaTeX. Cu acest pachet putem crea elemente grafice complexe utilizÃ¢nd aÈ™a elemente simple, cum ar fi linii, puncte, curbe, cercuri, dreptunghiuri, etc. Pentru imaginile desenate cu TikZ este oferitÄƒ o opÈ›iune dedicatÄƒ tikz care Ã®ncarcÄƒ acest pachet È™i configureazÄƒ mediul tikzpicture pentru a crea o singurÄƒ paginÄƒ decupatÄƒ 5. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:3:2","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea È™i animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"3.3. OpÈ›iunea border OpÈ›iunea border=10pt specificÄƒ cÄƒ documentul va avea un chenar de 10pt sau, cu alte cuvinte, va avea o margine din toate pÄƒrÈ›ile de 10pt. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:3:3","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea È™i animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"3.4. Importarea pachetelor necesare Distributivele moderne LaTeX vin cu un gama largÄƒ de pachete preinstalate. Pentru generarea evolventei ne vom folosi de pachetele pgfplots È™i amsmath. \\usepackage{pgfplots,amsmath} \\pgfplotsset{compat=newest} Pachetul pgfplots este un instrument puternic, fiind bazat pe TikZ, care este dedicat construirii graficelor È™tiinÈ›ifice. Acest pachet reprezintÄƒ un instrument de vizualizare pentru a simplifica includerea graficelor Ã®n documente. Ideea de bazÄƒ este cÄƒ furnizÄƒm datele/formule È™i pgfplots face restul 6. Configurarea \\pgfplotsset{compat=newest} ne permite sÄƒ utilizÄƒm cele mai recente caracteristici ale pachetului pgfplots. Pachetul amsmath Ã®l voi folosi pentru alinierea formulelor matematice, Ã®nsÄƒ funcÈ›ionalul acestui pachet nu se limiteazÄƒ doar la alinierea formulelor. Cu acest pachet puteÈ›i construi matrice, fracÈ›ii continue (fracÈ›ii incluse Ã®n fracÈ›ii), formule Ã®n chenar È™i multe altele. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:3:4","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea È™i animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"4. Definirea variabilelor necesare \\pgfmathsetmacro\\radius{2} % Colors \\definecolor{tangentLineColor}{HTML}{BC5090} \\definecolor{remainingArcColor}{HTML}{003F5C} \\definecolor{involuteSplineColor}{HTML}{58508D} \\definecolor{accentColor}{HTML}{FF6361} \\colorlet{dashedLineColor}{black} % Styles \\tikzstyle{information text}=[fill=red!10,inner sep=1ex] \\pgfplotsset{ /pgf/number format/textnumber/.style={ fixed, fixed zerofill, precision=2, 1000 sep={,}, }, } Ãn secÈ›iunea datÄƒ setÄƒm raza cercului. Toate calculele ulterioare for fi Ã®n bazÄƒ de valoarea setatÄƒ la variabila radius. Ulterior, setÄƒm culorile necesare pentru fiecare strat desenat pe graficul nostru. Aici se foloseÈ™te pachetul xcolor. Dar de ce nu l-am importat Ã®n preambul? Acest pachet nu trebuie Ã®n cazul nostru de importat din motiv cÄƒ tikz deja Ã®l utilizeazÄƒ. Profit ğŸ™‚! Ãn ultimele comenzi din aceastÄƒ secÈ›iune se seteazÄƒ un stil cu denumirea information text ce va avea 10% intensitate din culoarea roÈ™ie È™i mai seteazÄƒ precizia pÄƒrÈ›ii fracÈ›ionare a calculelor de 2 cifre. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:4:0","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea È™i animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"5. Construirea graficelor evolventei Ca sÄƒ construim animaÈ›ia evolventei unui cerc, vom proceda astfel. Prin comanda \\foreach vom desena cadru dupÄƒ cadru cÃ¢te un grafic unde ca valoare de iteraÈ›ie va fi unghiul de depanare a evolventei. Cu alte cuvinte, Ã®n fiÈ™ierul de ieÈ™ire pdf vom avea Ã®n fiecare paginÄƒ a cÃ¢te un grafic. \\foreach \\rollAngle in {0.05,0.1,...,3.25} { ... } Pentru construirea evolventei vom folosi radiani Ã®n loc de grade. Ãn ciclul foreach vedem cÄƒ unghiul de depanare Ã®ncepe de la $ \\psi_a = 0.05 rad $ È™i se terminÄƒ cu $ \\psi_b = 3.25 rad $. Pasul de la iteraÈ›ie la iteraÈ›ie este de $ \\psi_i = 0.05 rad $. Putem cu aceste date prealabil sÄƒ calculÄƒm numÄƒrul de cadre care vor fi Ã®n final. $$ \\frac{\\psi_b - \\psi_a}{\\psi_i} = \\frac{3.25 - 0.05}{0.05} = 64 $$ ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:5:0","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea È™i animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"5.1. SetÄƒri generale ale mediului tikzpicture la fiecare iteraÈ›ie Comenzile de desenare tikz (inclusiv È™i pgfplots) trebuie sÄƒ fie incluse Ã®ntr-un mediu tikzpicture. \\begin{tikzpicture} [ declare function = { involutex(\\radius,\\psi) = \\radius * (cos(\\psi) + \\psi * sin(\\psi)); involutey(\\radius,\\psi) = \\radius * (sin(\\psi) - \\psi * cos(\\psi)); arcx(\\radius,\\a,\\psi) = \\a + \\radius * cos(\\psi); arcy(\\radius,\\b,\\psi) = \\b + \\radius * sin(\\psi); }, ] ... \\end{tikzpicture} Ca opÈ›iune a mediului tikzpicture vom determina funcÈ›iile necesare pentru construirea graficelor. Ãn cod vedem 4 funcÈ›ii Ã®nsÄƒ Ã®n realitate merge vorba de doar douÄƒ, deoarece Ã®n pereche acestea alcÄƒtuiesc ecuaÈ›ii parametrice. Ãn matematicÄƒ, o ecuaÈ›ie parametricÄƒ defineÈ™te un grup de cantitÄƒÈ›i ca funcÈ›ii ale uneia sau mai multor variabile independente numite parametri. EcuaÈ›iile parametrice sunt utilizate Ã®n mod obiÈ™nuit pentru a exprima coordonatele punctelor care alcÄƒtuiesc un obiect geometric, cum ar fi o curbÄƒ sau o suprafaÈ›Äƒ, caz Ã®n care ecuaÈ›iile sunt denumite colectiv reprezentare parametricÄƒ sau parametrizare a obiectului 7. EcuaÈ›iile parametrice pentru reprezentarea graficÄƒ a evolventei sunt indicate mai jos, unde $r$ este raza cercului È™i $\\psi$ â€“ unghiul de â€œdepanare a aÈ›ei de pe mosorâ€ ğŸ˜„. $$ x = r(\\cos\\psi + \\psi\\sin\\psi) $$ $$ y = r(\\sin\\psi - \\psi\\cos\\psi) $$ Celelalte douÄƒ ecuaÈ›ii parametrice le vom folosi pentru a desena arcuri de cerc pe grafic, unde $r$ iarÄƒÈ™i este raza cercului, $\\psi$ â€“ unghiul arcului de cerc, iar $x_{\\tiny 0}$ È™i $y_{\\tiny 0}$ sunt coordonatele centrului cercului, Ã®n cazul Ã®n care acesta nu se aflÄƒ Ã®n origine. $$ x = x_{\\tiny 0} + r \\cos\\psi $$ $$ y = y_{\\tiny 0} + r \\sin\\psi $$ ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:5:1","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea È™i animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"5.2. Adaugarea variabilelor suplimentare La fiecare iteraÈ›ie vor fi efectuate cÃ¢teva calcule, rezultatele cÄƒrora vor fi salvate Ã®n variabile. Aceste variabile vor fi utile Ã®n continuare pentru afiÈ™area textualÄƒ a rezultatelor calculelor. \\pgfmathsetmacro\\rollAngleDeg{deg(\\rollAngle)} \\pgfmathsetmacro\\arcLength{0.5 * \\rollAngle * \\radius^2} \\pgfmathsetmacro\\curvature{1 / (\\radius * \\rollAngle)} Prima variabilÄƒ rollAngleDeg va conÈ›ine valoarea unghiului de depanare exprimatÄƒ Ã®n grade. Ulterior vom salva lungimea arcului evolventei Ã®n variabila arcLength. Aceasta are urmÄƒtoarea formulÄƒ: $$ L = \\frac{1}{2} \\psi r^2 $$ Ãn final, vom calcula curbarea È™i vom salva valoarea acesteia Ã®n variabila curvature. Formula pentru calcularea acesteia este urmÄƒtoarea: $$ \\kappa = \\frac{1}{\\psi r} $$ ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:5:2","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea È™i animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"5.3. SetÄƒri generale ale axelor graficului fiecÄƒrui cadru DeclaraÈ›ia de mediu \\begin {axis} È™i \\end {axis} va seta scalarea corectÄƒ a graficului. Noi vom folosi scalarea simplÄƒ liniarÄƒ, Ã®nsÄƒ acest pachet are È™i alte tipuri de scalÄƒri, pe care le puteÈ›i folosi la proiectarea altor grafice. \\begin{axis}[ name=plotAxis, trig format=rad, axis equal, axis lines=center, grid=both, xlabel=$x$, ylabel=$y$, xmin=-5,xmax=5, ymin=-3,ymax=7, xticklabels=\\empty, yticklabels=\\empty, ] ... \\end{axis} DupÄƒ cum observÄƒm, axele au un È™ir de opÈ›iuni atribuite. Ãn mod succint vom desfÄƒÈ™ura semnificaÈ›ia È™i utilitatea acestora. Grafic cu axe localizate Ã®n centru, scalare liniarÄƒ. 5.3.1. OpÈ›iunea name OpÈ›iunea name seteazÄƒ numele graficului. AceastÄƒ opÈ›iune ne va permite, accesÃ¢nd graficul dupÄƒ nume, sÄƒ poziÈ›ionÄƒm Ã®n dreapta acestuia o casetÄƒ informativÄƒ cu toate calculele evolventei la fiecare iteraÈ›ie. 5.3.2. OpÈ›iunea trig format=rad Pachetul pgfplots Ã®n mode implicit opereazÄƒ cu grade, atunci cÃ¢nd avem calcule ce conÈ›in funcÈ›ii trigonometrice. Pentru proiectarea evolventei vom utiliza radiani. OpÈ›iunea trig format permite reconfigurarea formatului de intrare pentru funcÈ›ii trigonometrice precum sinus, cosinus, tangentÄƒ, etc 8. 5.3.3. OpÈ›iunea axis equal Cu ajutorul opÈ›iunii axis equal, fiecare vector de unitate este setat la aceeaÈ™i lungime, Ã®n timp ce dimensiunile axei rÄƒmÃ¢n constante. DupÄƒ aceea, raporturile de mÄƒrime pentru fiecare unitate Ã®n x È™i y vor fi aceleaÈ™i. Limitele axei vor fi extinse pentru a compensa efectul de scalare 9. 5.3.4. OpÈ›iunea axis lines=center Ãn mod implicit, liniile de axe sunt desenate ca o casetÄƒ, Ã®nsÄƒ este posibil de modificat aspectul liniilor axelor x È™i y. Atribuirea unei valori din cele disponibile, va permite alegerea locaÈ›iei pentru liniile axelor graficului 10. Noi vom seta valoarea center, ceea ce va Ã®nsemna cÄƒ axele se vor intersecta Ã®n coordonata 0 (origine). 5.3.5. OpÈ›iunea grid=both AceastÄƒ opÈ›iune va desena liniile de grilÄƒ pe grafic. 5.3.6. OpÈ›iunile xlabel È™i ylabel Aceste opÈ›iuni vor desena etichetele axelor graficului, adicÄƒ textul x È™i y. Simbolul $ specificÄƒ cÄƒ textul reprezintÄƒ o formulÄƒ matematicÄƒ. 5.3.7. OpÈ›iunile xmin, xmax, ymin È™i ymax Aceste opÈ›iuni permit definirea limitelor axelor, adicÄƒ colÈ›ul din stÃ¢nga jos È™i cel din dreapta sus. Tot conÈ›inutul ce se va afla Ã®n afara acestor limite va fi eliminat 11. 5.3.8. OpÈ›iunile xticklabels È™i yticklabels Aceste opÈ›iuni permit atribuirea etichetelor pentru fiecare pas a axei (segmente ale axelor). Ãn cazul nostru, nu avem nevoie de etichetele cu numerotarea fiecÄƒrui segment al axelor. Pentru aceasta, vom seta la aceste opÈ›iuni valoarea \\empty (gol). ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:5:3","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea È™i animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"5.4. AdÄƒugarea coordonatelor necesare pe grafic Ãn continuare, vom adÄƒuga 3 coordonate pe grafic, È™i anume $O$, $L_{\\tiny 1}$ È™i $L_{\\tiny 2}$. Aceste coordonate ne vor permite sÄƒ trasÄƒm segmente. Sintaxa de adÄƒugare a coordonatei pe grafic este urmÄƒtoarea: \\coordonate[\u003coptions\u003e] (\u003cname\u003e) at (\u003ccoordonate\u003e); Deci, coordonatele $O$, $L_{\\tiny 1}$ È™i $L_{\\tiny 2}$ vor fi adaugate astfel: \\coordonate (O) at (0,0); \\coordonate (L1) at ({arcx(\\radius,0,\\rollAngle)},{arcy(\\radius,0,\\rollAngle)}); \\coordonate (L2) at ({involutex(\\radius,\\rollAngle)},{involutey(\\radius,\\rollAngle)}); Segmentul $OL_{\\tiny 1}$ va reprezenta raza cercului, iar unghiul dintre acest segment È™i segmentul $[0,r]$ va fi Ã®nsÄƒÈ™i unghiul de depanare. Segmentul $L_{\\tiny 1}L_{\\tiny 2}$ va reprezenta tangenta cercului, pornind de la perpendicularÄƒ spre punctul maxim al evolventei (calculÃ¢nd valorile ecuaÈ›iilor parametrice, unde $\\psi$ va fi egal cu valoarea curentÄƒ a variabilei \\rollAngle). coordonatele $O$, $L_1$ È™i $L_2$ pe grafic. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:5:4","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea È™i animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"5.5. Proiectarea arcului de cerc rÄƒmas dupÄƒ depanare FiindcÄƒ am menÈ›ionat cÄƒ evolventa o putem reprezenta ca depanarea aÈ›ei de pe mosor, atunci la fiecare iteraÈ›ie vom elimina o parte din cerc care corespunde cu unghiul \\rollAngle. Arcul de cerc rÄƒmas dupÄƒ depanare. Comanda \\addplot este principala comandÄƒ de construire a graficelor, disponibilÄƒ Ã®n fiecare mediu de axe. Aceasta poate fi folositÄƒ de una sau mai multe ori Ã®n cadrul axelor pentru a adÄƒuga mai multe grafice 12. Sintaxa de adaugare a graficului pe axe este urmÄƒtoarea: \\addplot[\u003coptions\u003e] \u003cinput data\u003e \u003ctrailing path commands\u003e; Deci, pentru a construi graficul cu arcul de cerc rÄƒmas dupÄƒ depanare, vom scrie urmÄƒtoarea comandÄƒ: \\addplot [domain=2*pi:\\rollAngle,samples=200,remainingArcColor,thick,line cap=round]({arcx(\\radius,0,x)},{arcy(\\radius,0,x)}); OpÈ›iunile setate la construirea graficului le vom desfÄƒÈ™ura Ã®n continuare, excepÈ›ie fiind remainingArcColor. AceastÄƒ opÈ›iune doar seteazÄƒ culoarea graficului cu cea declaratÄƒ Ã®n una din secÈ›iunile anterioare. 5.5.1. OpÈ›iunea domain AceastÄƒ opÈ›iune ne permite de a seta domeniul de definiÈ›ie al funcÈ›iei. Expresiile graficelor bidimensionale sunt definite ca funcÈ›ii $f: [x_{\\tiny 1},x_{\\tiny 2}] \\to \\mathbb{R}$ È™i $\\langle x_{\\tiny 1} \\rangle$ È™i $\\langle x_{\\tiny 2} \\rangle$ sunt setate cu opÈ›iunea domain 13. Ãn cazul nostru, domeniul de definiÈ›ie este $f: [2\\pi:\\psi] \\to \\mathbb{R}$, unde $\\psi$ este unghiul curent de depanare, egal cu valoarea variabilei \\rollAngle. Cu alte cuvinte, de la iteraÈ›ie la iteraÈ›ie cercul va pierde o parte din el. Unghiul arcului de cerc eliminat din cerc va corespunde cu valoarea \\rollAngle. 5.5.2. OpÈ›iunea samples AceastÄƒ opÈ›iune seteazÄƒ numÄƒrul de puncte de prelevare (sample points) 8. Este de menÈ›ionat cÄƒ aceste prelevÄƒri se vor conÈ›ine Ã®n domeniul de definiÈ›ie setat anterior. 5.5.3. Stilul TikZ thick AceastÄƒ stil permite setarea lÄƒÈ›imii liniei graficului. Stilul thick, pe care l-am selectat, corespunde cu lÄƒÈ›imea de linie 0.8pt 14. TikZ oferÄƒ lÄƒÈ›imi de linie predefinite, dupÄƒ cum urmeazÄƒ 15: thin ultra thin very thin semithick thick very thick ultra thick 5.5.4. OpÈ›iunea line cap AceastÄƒ opÈ›iune specificÄƒ modul Ã®n care liniile â€œse terminÄƒâ€. Tipurile permise sunt round, rect È™i butt. Acestea au urmÄƒtoarele efecte 16: Tipurile de terminaÈ›ii ale liniilor. Credits: CTAN Pentru reprezentarea graficÄƒ a tuturor ecuaÈ›iilor parametrice, vom folosi terminaÈ›ii de linii rotunjite, adicÄƒ vom folosi opÈ›iunea line cap=round. Ãn mod similar, cu aceste opÈ›iuni descrise, vom construi È™i celelalte grafice. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:5:5","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea È™i animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"5.6. Proiectarea arcului de cerc depanat Prin comanda de mai jos, vom construi la fiecare iteraÈ›ie un arc de cerc punctat (opÈ›iunea dashedLineColor), care va reprezenta unghiul de depanare al evolventei pe cerc. Acest arc de cerc va avea domeniul de definiÈ›ie exact invers cu cel anterior, adicÄƒ $f: [0:\\psi] \\to \\mathbb{R}$. \\addplot [domain=0:\\rollAngle,samples=200,dashedLineColor,dashed,line cap=round]({arcx(\\radius,0,x)},{arcy(\\radius,0,x)}); Ca rezultat, vizual vom avea un singur cerc care de fapt constÄƒ din douÄƒ arcuri de cerc opuse, cu culori È™i stiluri diferite. Proiectarea arcului de cerc depanat. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:5:6","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea È™i animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"5.7. Proiectarea evolventei IatÄƒ am ajuns È™i la cel mai important punct. Aici vom construi evolventa propriu-zisÄƒ. La construirea acesteia vom folosi ecuaÈ›iile parametrice discutate anterior anterior. \\addplot [domain=0.01:\\rollAngle,samples=200,involuteSplineColor,thick,line cap=round]({involutex(\\radius,x)},{involutey(\\radius,x)}); Ca rezultat, obÈ›inem profilul evolventei: Profilul evolventei pe grafic. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:5:7","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea È™i animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"5.8. Proiectarea liniei ce uneÈ™te tangenta cu capÄƒtul evolventei UrmÄƒtorul pas va fi trasarea liniei care uneÈ™te tangenta cu capÄƒtul evolventei. Acest lucru Ã®l vom realiza cu ajutorul comenzii \\draw. AceastÄƒ linie va avea culoarea atribuitÄƒ Ã®n variabila tangentLineColor, lÄƒÈ›imea liniei va fi de tip thick È™i va avea coordonatele L1 È™i L2 care le-am declarat È™i iniÈ›ializat Ã®n una din secÈ›iunile precedente. \\draw[tangentLineColor,thick] (L1) -- (L2); Linia aceasta va reprezenta acea â€œaÈ›Äƒâ€, pe care o depÄƒnÄƒm de pe mosor ğŸ§µ. Rezultatul aratÄƒ astfel: Linia ce uneÈ™te tangenta cu capÄƒtul evolventei. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:5:8","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea È™i animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"5.9. Proiectarea razei cercului Tot cu aceeaÈ™i sintaxÄƒ vom proiecta raza cercului care se va roti odatÄƒ cu mÄƒrirea unghiului de depanare. \\draw[dashedLineColor,dashed] (O) -- (L1) node [accentColor,pos=0.5,sloped,above] {$r$}; Rezultatul Ã®l putem vedea Ã®n animaÈ›ia de mai jos, Ã®nsÄƒ opÈ›iunile pe care le-am setat la nod, le vom desfÄƒÈ™ura Ã®n secÈ›iunile urmÄƒtoare. Proiectarea razei cercului. 5.9.1. OpÈ›iunea /tikz/pos OpÈ›iunea /tikz/pos=\u003cfraction\u003e ancoreazÄƒ nodul pe un anumit punct de pe linie de la coordonata anterioarÄƒ la acea actualÄƒ. \u003cfraction\u003e dicteazÄƒ cÃ¢t de â€œdeparteâ€ trebuie sÄƒ fie punctul pe linie. \u003cfraction\u003e setat ca $0$ reprezintÄƒ coordonata anterioarÄƒ, $1$ este cea curentÄƒ, iar toate celelalte valori vor fi Ã®ntre ele. Ãn special, $0.5$ reprezintÄƒ mijlocul liniei 17. Noi vom seta valoarea $0.5$, ceea ce va Ã®nsemna cÄƒ nodul se afla la mijloc de linie. AcelaÈ™i lucru Ã®l putem face cu opÈ›iunea /tikz/midway, care este echivalentul opÈ›iunii pos=0.5. 5.9.2. OpÈ›iunea /tikz/sloped OpÈ›iunea /tikz/sloped face ca nodul sÄƒ fie rotit, astfel Ã®ncÃ¢t linia orizontalÄƒ a acestuia sÄƒ devinÄƒ tangentÄƒ cu curba. Rotirea de obicei se face Ã®n aÈ™a mod, Ã®ncÃ¢t textul sÄƒ nu fie niciodatÄƒ â€œcu susul Ã®n josâ€. 18. OpÈ›iunea /tikz/sloped din pachetul TikZ. Credits: CTAN Ãn cazul nostru avem nu o curbÄƒ, ci o linie È™i textul trebuie sÄƒ se roteascÄƒ odatÄƒ cu rotirea liniei. La momentul cÃ¢nd unghiul de depanare va depÄƒÈ™i $\\frac{\\pi}{2}$ radiani sau $90^{\\circ}$, aceastÄƒ opÈ›iune nu va permite ca textul sÄƒ fie inversat (cu susul Ã®n jos). 5.9.3. OpÈ›iunea /tikz/above AceastÄƒ opÈ›iune este echivalentÄƒ cu opÈ›iunea /tikz/anchor=south È™i permite poziÈ›ionarea nodului deasupra liniei. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:5:9","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea È™i animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"5.10. Proiectarea unghiului arcului de cerc depanat La aceastÄƒ etapÄƒ, vom proiecta unghiul arcului de cerc depanat. Pentru aceasta, vom utiliza comanda \\addplot, sintaxa cÄƒreia am desfÄƒÈ™urat-o Ã®n una din secÈ›iunile anterioare. Unica diferenÈ›Äƒ este cÄƒ aici adÄƒugÄƒm un nod fix poziÈ›ionat Ã®n punctul $(0.5,-0.3)$ cu textul $\\psi$. \\addplot [domain=0:\\rollAngle,samples=200,accentColor,line cap=round]({arcx(.4,0,x)},{arcy(.4,0,x)}) node[] at (.5, -.3) {$\\psi$}; Desigur cÄƒ $\\LaTeX$ dispune de o gamÄƒ largÄƒ de pachete pentru desenarea unghiurilor (cum ar fi pachetul tkz-euclide), Ã®nsÄƒ vom merge pe calea proiectÄƒrii aceluiaÈ™i arc de cerc, numai cÄƒ cu o razÄƒ mai micÄƒ. Proiectarea unghiului depanÄƒrii evolventei. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:5:10","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea È™i animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"5.11. AfiÈ™area parametrilor evolventei la fiecare iteraÈ›ie Parametrii evolventei la fiecare iteraÈ›ie vor fi poziÈ›ionaÈ›i Ã®ntr-o casetÄƒ, ultima fiind poziÈ›ionatÄƒ Ã®n dreapta graficului nostru. AfiÈ™area parametrilor evolventei la fiecare iteraÈ›ie. Codul casetei cu parametrii evolventei Ã®l putem vedea mai jos: \\node [xshift=.5cm,below right,align=center,text width=6cm,style=information text] at (plotAxis.north east) { This is a demonstration how the {\\color{accentColor} involute of a circle} works. So, {\\color{accentColor} $r$} is radius of the circle, {\\color{accentColor} $\\psi$} --- roll angle, {\\color{accentColor} $L$} --- arc length and {\\color{accentColor} $k$} -- curvature of the involute. \\begin{align*} {\\color{accentColor} r} \u0026 = const \u0026 \u0026 = \\radius \\\\ {\\color{accentColor} \\psi} \u0026 = \\pgfmathprintnumber[textnumber]{\\rollAngle}\\text{ rad} \u0026 \u0026 \\approx \\pgfmathprintnumber[textnumber]{\\rollAngleDeg}^\\circ \\\\ {\\color{accentColor} L} \u0026 = \\frac{1}{2} \\psi r^2 \u0026 \u0026 = \\pgfmathprintnumber[textnumber]{\\arcLength} \\\\ {\\color{accentColor} \\kappa} \u0026 = \\frac{1}{\\psi r} \u0026 \u0026 \\approx \\pgfmathprintnumber[textnumber]{\\curvature} \\end{align*} }; AceastÄƒ porÈ›iune de cod de la prima vedere pare a fi dificilÄƒ. Ãn secÈ›iunile ulterioare vom explica unele momente-cheie ce au loc Ã®n acest fragment de cod. 5.11.1. Commanda \\node Nodurile sunt probabil cele mai universale elemente din TikZ. Un nod este de obicei un dreptunghi sau un cerc sau o altÄƒ formÄƒ simplÄƒ cu un text pe el. Ãn cel mai simplu caz, un nod este doar un text care este plasat la o anumitÄƒ coordonatÄƒ. \\node[\u003coptions\u003e](\u003cname\u003e) at (\u003ccoordinate\u003e){\u003ctext\u003e}; Ãn cazul nostru, vom crea un nod cu coordonata localizatÄƒ Ã®n colÈ›ul drept sus al graficului principal. Acest lucru se realizeazÄƒ prin referirea cÄƒtre numele axei graficului principal, cu indicarea ancorei (punctului de referinÈ›Äƒ a nodului) Ã®n poziÈ›ia nord-est. Ancore poziÈ›ionate pe caseta de delimitare a axei din pachetul TikZ. Credits: CTAN OpÈ›iunea xshift=.5cm permite de a executa translaÈ›ia casetei pe axa $x$ cu 0.5cm, below right â€“ poziÈ›ionarea casetei Ã®n dreapta sub coordonata setatÄƒ anterior È™i cu luarea Ã®n considerare a translaÈ›iei efectuate. OpÈ›iunea /tikz/text width=6cm va plasa textul nodului Ã®ntr-o casetÄƒ de 6cm lÄƒÈ›ime. DacÄƒ lÄƒÈ›imea textului va depÄƒÈ™i aceastÄƒ limitÄƒ, atunci se va Ã®ntrerupe linia È™i se va trece conÈ›inutul rÄƒmas din rÃ¢nd nou. Ãn ceea ce priveÈ™te opÈ›iunea /tikz/align=center, aceasta este utilizatÄƒ pentru a configura alinierea textului cu mai multe linii Ã®n interiorul unui nod. DacÄƒ opÈ›iunea /tikz/text width este setatÄƒ la o anumitÄƒ lÄƒÈ›ime (sÄƒ numim aceastÄƒ aliniere cu line breaking), opÈ›iunea de aliniere va configura \\leftskip È™i \\rightskip Ã®n aÈ™a fel Ã®ncÃ¢t textul sÄƒ fie Ã®ntrerupt È™i aliniat Ã®n funcÈ›ie de opÈ›iunea de aliniere 19. OpÈ›iunea style=information text permite de a seta stilul pe care l-am identificat Ã®n una din secÈ›iunile anterioare. AceastÄƒ casetÄƒ cu parametrii evolventei la fiecare iteraÈ›ie va avea o culoare de fundal roÈ™ie cu intensitatea de 10% din culoarea de bazÄƒ. 5.11.2. AfiÈ™area textului color Pentru afiÈ™area unui text color Ã®n nod, putem utiliza sintaxa de mai jos, denumirile culorilor fiind identificate Ã®n primele secÈ›iuni. {\\color{accentColor} some text} 5.11.3. Alinierea formulelor matematice din casetÄƒ Formulele matematice nu vor fi aliniate Ã®ntr-o formÄƒ simplÄƒ (stÃ¢nga, centru, dreapta), ci va avea o formÄƒ complexÄƒ. Alinierea se va face la simbolul =, cu alte cuvinte toate cele 4 formule se vor poziÈ›iona una sub alta cu alinierea strict la acest simbol. Alinierea formulelor matematice dupÄƒ simbolul egal. Acest lucru se face cu ajutorul pachetului amsmath, folosind construcÈ›ia \\begin{align*} ... \\end{align*} È™i determinÃ¢nd prin simbolul \u0026 locul unde avem nevoie sÄƒ aliniem ecuaÈ›ia. \\begin{align*} {\\color{accentColor} r} \u0026 = const \u0026 \u0026 = \\radius \\\\ \\end{align*} Despre semnificaÈ›ia È™i utilitatea simbolului \u0026 Ã®n acest pachet puteÈ›i citi aici. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:5:11","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea È™i animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"6. Producerea fiÈ™ierului de ieÈ™ire final cu animarea evolventei Dat fiind faptului cÄƒ lucrÄƒm Ã®n devContainer, deja avem toate pachetele instalate pentru convertirea fiÈ™ierului pdf Ã®n mp4 (fiÈ™ier video cu animarea evolventei). Era posibilÄƒ convertirea Ã®n fiÈ™ier gif dar acest format este unul Ã®nvechit È™i are o serie de dezavantaje. ExistÄƒ o mulÈ›ime de formate mai performante, cum ar fi webp, apng È™i altele. Nu vom folosi aceste formate, fiindcÄƒ problema constÄƒ Ã®n compatibilitate. Aceste formate nu sunt suportate pe deplin de toate browserele (exemplu pentru apng, webp). Cea mai optimÄƒ variantÄƒ este mp4. Acest format È™i codecul H.264 este suportat practic de toate browserele. Putem seta È™i opÈ›iunea loop pentru repetarea ciclicÄƒ a video-ului È™i, astfel, vom obÈ›ine acelaÈ™i efect ca È™i Ã®n cazul unui fiÈ™ier de tip gif. Prima etapÄƒ este convertirea fiÈ™ierului pdf generat de LaTeX Ã®ntr-o secvenÈ›Äƒ de imagini cu ajutorul pachetului GraphicsMagick. Cu alte cuvinte, fiecare foaie din fiÈ™ier va fi salvatÄƒ Ã®n imagini distincte cu extensia png. Pentru a realiza aceastÄƒ convertire, ne vom folosi de comanda de mai jos, care va salva secvenÈ›e de imagini cu densitatea de 300 DPI È™i fundal alb. mkdir involute-of-circle/output/ gm convert -density 300 involute-of-circle/involute-demo.pdf -background white +adjoin involute-of-circle/output/image_%02d.png # AlternativÄƒ folosind pachetul Ghostscript gs -sDEVICE=pngalpha -o involute-of-circle/output/image_%02d.png -r300 involute-of-circle/involute-demo.pdf UrmÄƒtorul pas este convertirea secvenÈ›ei de imagini Ã®n fiÈ™ier video de tip mp4. Pentru aceasta, ne vom folosi de pachetul preinstalat in container care se numeÈ™te FFmpeg. ffmpeg -r 15 -i involute-of-circle/output/image_%02d.png -c:v libx264 -vf fps=60 -pix_fmt yuv420p -vf \"pad=ceil(iw/2)*2:ceil(ih/2)*2\" involute-of-circle/output/out.mp4 ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:6:0","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea È™i animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"7. Concluzie $\\LaTeX$ este un sistem avansat de preparare a documentului. Acesta dispune de un numÄƒr larg de pachete care permit realizarea unor sarcini complexe. Ãn acest articol am folosit pachetul PGFPlots (care la rÃ¢ndul sÄƒu foloseste pachetul TikZ), pentru a proiecta evolventa unui cerc. Animarea evolventei am realizat-o cu ajutorul ciclului foreach, unde la fiecare iteraÈ›ie am modificat unghiul de depanare. Ca rezultat am obÈ›inut un fiÈ™ier pdf cu cadrele necesare pentru animare. Ulterior, acest fiÈ™ier l-am convertit Ã®n fiÈ™ier mp4 cu ajutorul pachetului GraphicsMagick. Rezultatul final. ExperimentÃ¢nd cu evolvente, putem obÈ›ine astfel de figuri: Experimente cu evolvente. Codul deplin se aflÄƒ pe repository Github. Disclaimer Imaginea reprezentativÄƒ a acestui articol conÈ›ine elemente grafice preluate de pe Freepik (design de cÄƒtre macrovector). What are TEX and its friends? Credits: CTANÂ â†©ï¸ Dockerfile reference. Credits: docs.docker.comÂ â†©ï¸ Standalone: class vs package. StackOverflowÂ â†©ï¸ Martin Scharrer. The standalone Package, v1.3a din 26.03.2018, p.1. Credits: CTANÂ â†©ï¸ Martin Scharrer. The standalone Package, v1.3a din 26.03.2018, p.8. Credits: CTANÂ â†©ï¸ Pgfplots package. Credits: OverleafÂ â†©ï¸ Parametric equation. Credits: WikipediaÂ â†©ï¸ Dr. Christian FeuersÃ¤nger. Manual for Package pgfplots, v1.17 din 29.02.2020, p.56. Credits: CTANÂ â†©ï¸Â â†©ï¸ Dr. Christian FeuersÃ¤nger. Manual for Package pgfplots, v1.17 din 29.02.2020, p.298. Credits: CTANÂ â†©ï¸ Dr. Christian FeuersÃ¤nger. Manual for Package pgfplots, v1.17 din 29.02.2020, p.270-271. Credits: CTANÂ â†©ï¸ Dr. Christian FeuersÃ¤nger. Manual for Package pgfplots, v1.17 din 29.02.2020, p.327. Credits: CTANÂ â†©ï¸ Dr. Christian FeuersÃ¤nger. Manual for Package pgfplots, v1.17 din 29.02.2020, p.43. Credits: CTANÂ â†©ï¸ Dr. Christian FeuersÃ¤nger. Manual for Package pgfplots, v1.17 din 29.02.2020, p.55. Credits: CTANÂ â†©ï¸ LaTeX/PGF/TikZ. Line width. Credits: WikibooksÂ â†©ï¸ Dr. Christian FeuersÃ¤nger. Manual for Package pgfplots, v1.17 din 29.02.2020, p.190. Credits: CTANÂ â†©ï¸ Till Tantau È™i alti autori. TikZ \u0026 PGF. Manual for Version 3.1.5b, v3.1.5b din 08.01.2020, p.175. Credits: CTANÂ â†©ï¸ Till Tantau È™i alti autori. TikZ \u0026 PGF. Manual for Version 3.1.5b, v3.1.5b din 08.01.2020, p.246. Credits: CTANÂ â†©ï¸ Till Tantau È™i alti autori. TikZ \u0026 PGF. Manual for Version 3.1.5b, v3.1.5b din 08.01.2020, p.248. Credits: CTANÂ â†©ï¸ Till Tantau È™i alti autori. TikZ \u0026 PGF. Manual for Version 3.1.5b, v3.1.5b din 08.01.2020, p.235. Credits: CTANÂ â†©ï¸ ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:7:0","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea È™i animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"Introducere Ãn acest articol se demonstreazÄƒ construirea unui Plugin pentru aplicaÈ›ia QGIS 3, ce foloseÈ™te serviciile Map.md API. AvÃ¢nd o experienÈ›Äƒ modestÄƒ Ã®n limbajul Python, Ã®n acest articol pot fi Ã®ntÃ¢lnite â€biciclete inventateâ€œ ğŸ˜„. Voi fi recunoscÄƒtor dacÄƒ veÈ›i oferi sfaturi cum ar fi posibil sÄƒ Ã®mbunÄƒtÄƒÈ›esc codul scris. Ãntr-o bunÄƒ zi, navigÃ¢nd pe reÈ›eaua LinkedIn, am dat de postarea lui Roman È˜tirbu, CEO al companiei Simpals. Ãn aceastÄƒ postare, dumnealui a menÈ›ionat cÄƒ a fost lansat serviciul API al sitului Map.md pentru companii care au nevoie de integrare cu CRM sau alte soluÈ›ii IT. Pentru mine a fost o noutate extraordinarÄƒ. OperÃ¢nd adesea cu date geospaÈ›iale, aveam nevoie de un serviciu similar pentru geocodificarea adreselor. Sigur cÄƒ la momentul actual existau serviciile Google Geocoding API È™i OpenStreetMap Nominatim, Ã®nsÄƒ nu eram satisfÄƒcut de rezultatele obÈ›inute ale acestor servicii. AflÃ¢nd de acest serviciu, imediat mi-a venit o idee de a-l implementa Ã®n aplicaÈ›ia QGIS, prin construirea unui Plugin ğŸ’¡. La elaborarea acestuia, m-am inspirat din extensia deja existentÄƒ MMQGIS. Printre multiplele funcÈ›ionalitÄƒÈ›i ce le are, acesta dispune È™i de geocodificarea adreselor prin intermediul serviciilor menÈ›ionate anterior. ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:1:0","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Crearea È™ablonului extensiei QGIS (QGIS Plugin) Pentru a crea È™ablonul extensiei QGIS, este nevoie de aplicaÈ›ia propriu-zisÄƒ instalatÄƒ Ã®n calculator È™i de extensiile Plugin Builder 3, debugvs È™i Plugin Reloader. ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:2:0","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Generarea È™ablonului cu ajutorul extensiei Plugin Builder 3 La pornirea acestei aplicaÈ›ii navigÄƒm meniul Plugins â–º Plugin Builder â–º Plugin Builder. DupÄƒ afiÈ™area dialogului, completÄƒm forma cu detaliile referitoare la extensie. ApÄƒsÃ¢nd butonul next, introducem informaÈ›ia detailatÄƒ privind extensia QGIS, È™ablonul cÄƒreia urmeazÄƒ a fi creat. Ãn urmÄƒtoarea formÄƒ, alegem È™ablonul Tool button with dialog, meniul Plugins È™i numele elementului meniului, spre exemplu, MapMD. SÄƒrind la urmÄƒtorul pas, selectÄƒm toate opÈ›iunile, pentru a avea o funcÈ›ionalitate mai vastÄƒ a extensiei. La urmÄƒtorul pas, suplinim forma privind publicarea extensiei. Pentru aceasta, eu am creat prealabil un repository pe Github È™i am introdus datele indicate Ã®n imaginea de mai jos. Plus la aceasta, am marcat extensia datÄƒ ca experimentalÄƒ, deoarece aceasta se va afla la starea de development È™i va fi instabilÄƒ la Ã®nceput. La ultimul pas, alegem mapa unde va fi generat proiectul È™i apÄƒsÄƒm butonul Generate. ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:2:1","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Note suplimentare privind procesul de generare al È™ablonului extensiei NotÄƒ: Pentru a putea face development È™i debugging este necesar ca proiectul cu extensie sÄƒ fie localizat aici: %APPDATA%\\QGIS\\QGIS3\\profiles\\default\\python\\plugins\\map_md_geocoding Ãn caz cÄƒ se afiÈ™eazÄƒ avertizare The resource compiler pyrccc5 was not found in your path, omitem È™i primim o instrucÈ›ie cu paÈ™ii ulteriori pentru a avea posibilitatea dezvolta cu succes extensia. ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:2:2","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Configurarea mediului de dezvoltare al extensiei Pentru dezvoltarea extensiei, este nevoie de configurat mediul de dezvoltare. Ãn acest scop, folosesc sistemul de operare Windows 10 È™i editorul Visual Studio Code. ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:3:0","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"PregÄƒtirea mediului de dezvoltare Ãn mapa cu extensia datÄƒ creÄƒm un fiÈ™ier cu denumirea start_vscode.cmd È™i scrim instrucÈ›iunile de mai jos. De fiecare datÄƒ cÃ¢nd va fi necesar de dezvoltat extensia, vom rula acest fiÈ™ier. Acest fiÈ™ier seteazÄƒ variabilele de mediu necesare pentru dezvoltarea È™i debugging-ul extensiei È™i, ulterior, lanseazÄƒ editorul VS Code. @echo off SET OSGEO4W_ROOT=C:\\OSGeo4W64 call \"%OSGEO4W_ROOT%\"\\bin\\o4w_env.bat call \"%OSGEO4W_ROOT%\"\\bin\\qt5_env.bat call \"%OSGEO4W_ROOT%\"\\bin\\py3_env.bat path %PATH%;%OSGEO4W_ROOT%\\apps\\qgis\\bin path %PATH%;%OSGEO4W_ROOT%\\apps\\Qt5\\bin path %PATH%;%OSGEO4W_ROOT%\\apps\\Python37\\Scripts path %PATH%;C:\\Program Files\\7-Zip path %PATH%;C:\\Program Files\\Git\\cmd set PYTHONPATH=%PYTHONPATH%;%OSGEO4W_ROOT%\\apps\\qgis\\python\\ set PYTHONPATH=%PYTHONPATH%;%OSGEO4W_ROOT%\\apps\\qgis\\python\\qgis set PYTHONPATH=%PYTHONPATH%;%OSGEO4W_ROOT%\\apps\\qgis\\python\\qgis\\PyQt5 set PYTHONPATH=%PYTHONPATH%;%OSGEO4W_ROOT%\\apps\\qgis\\python\\qgis\\core set PYTHONHOME=%OSGEO4W_ROOT%\\apps\\Python37 start \"VS Code with PyQGIS and OsGeo4W\" /B \"%LOCALAPPDATA%\\Programs\\Microsoft VS Code\\Code.exe\" . Ãn VS Code, creÄƒm un nou fiÈ™ier Ã®n mapa generatÄƒ a extensiei cu denumirea requirements.txt È™i introducem Ã®n el pachetele necesare pentru instalare Ã®n mediul virtual: autopep8 pb_tool ptvsd sphinx_rtd_theme Ulterior, instalÄƒm aceste pachete, efectuÃ¢nd urmÄƒtoarea instrucÈ›iune: pip install -r requirements.txt AvÃ¢nd pachetele necesare instalate, compilÄƒm resursele aplicaÈ›iei prin efectuarea instrucÈ›iunii de mai jos. Aceasta va genera fiÈ™ierul resources.py. pb_tool compile ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:3:1","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Verificarea funcÈ›ionalitÄƒÈ›ii extensiei Pentru a verifica dacÄƒ totul funcÈ›ioneazÄƒ bine, lansÄƒm proiectul prin executarea instrucÈ›iunii de mai jos. Aceasta trebuie sa compileze proiectul È™i sÄƒ-l copie Ã®n mapa cu extensiile QGIS. pb_tool deploy DupÄƒ, pornim aplicaÈ›ia QGIS È™i activÄƒm extensia noastrÄƒ prin navigarea meniului Plugins â–º Manage and Install Plugins... â–º Installed â–º MapMD. Ulterior, pornim extensia creatÄƒ prin apÄƒsarea butonului corespunzÄƒtor de pe bara de instrumente. ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:3:2","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Ajustarea interfeÈ›ei extensiei Pentru a adÄƒuga elemente Ã®n interfaÈ›a extensiei, este necesar de a rula aplicaÈ›ia Qt Designer. Aceasta o gÄƒsiÈ›i pe urmÄƒtoarea cale C:\\OSGeo4W64\\bin\\qgis-designer.bat. Apoi, deschideÈ›i cu ajutorul acestei aplicaÈ›ii fiÈ™ierul map_md_dialog_base.ui ce se aflÄƒ Ã®n mapa cu proiectul extensiei, adÄƒugaÈ›i componentele necesare È™i salvaÈ›i fiÈ™ierul, ca urmare fereastra sÄƒ arate Ã®n felul urmÄƒtor: ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:4:0","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Crearea clasei destinatÄƒ procesului de geocodificare Pentru a implementa funcÈ›ionalitÄƒÈ›ile extensiei, metodele ulterioare le-am inclus Ã®ntr-o clasÄƒ distinctÄƒ care va fi moÈ™tenitÄƒ de la clasa QgsTask. AceastÄƒ clasÄƒ permite ca procesul de geocodificare sÄƒ fie adÄƒugat Ã®n managerul de sarcini al aplicaÈ›iei QGIS, cu alte cuvinte extensia nu va bloca interfaÈ›a aplicaÈ›iei geospaÈ›iale È™i procesul de geocodificare va putea fi Ã®ntrerupt la cererea utilizatorul, ca rezultat afiÈ™Ã¢ndu-se numai adresele geocodificare pÃ¢nÄƒ la aceastÄƒ Ã®ntrerupere. Ãn aceastÄƒ clasÄƒ am importat bibliotecile necesare È™i am declarat variabilele cu care voi opera pe parcurs, denumirea celor private Ã®ncepÃ¢ndu-se cu douÄƒ simboluri underscore (â€_â€). Constructorul clasei conÈ›ine argumente cu valori implicite care sunt opÈ›ionale. import csv import codecs import sqlite3 import urllib.parse import re import requests import shapely from shapely.geometry import shape # pylint: disable=import-error from qgis.utils import iface from qgis.core import (QgsDataSourceUri, Qgis, QgsTask, QgsMessageLog) # pylint: enable=import-error # Clasa moÈ™tenitÄƒ de la clasa QgsTask, # ce permite adÄƒugarea sarcinii de geocodificare Ã®n # managerul de sarcini al aplicaÈ›iei Qgis. class MapMdUtils(QgsTask): def __init__(self, input_filename, output_filename=\"\", notfound_filename=\"\", api_key=\"\", street1_index=-1, street2_index=-1, house_number_index=-1, locality_index=-1): # Se apeleazÄƒ constructorul clasei QgsTask, # unde se introduce denumirea sarcinii È™i abilitatea de a # Ã®ntrerupe procesul de geocodificare. super().__init__(\"Geocodificarea adreselor\", QgsTask.CanCancel) self.__api_key = api_key # Cheia API self.__street1_index = street1_index # Indicele coloanei Strada1 self.__street2_index = street2_index # Indicele coloanei Strada2 self.__house_number_index = house_number_index # Indicele coloanei numÄƒrul casei self.__locality_index = locality_index # Indicele coloanei Localitate self.__input_filename = input_filename # Calea spre fiÈ™ierul de intrare self.__output_filename = output_filename # Calea spre fiÈ™ierul de ieÈ™ire self.__notfound_filename = notfound_filename # Calea spre fiÈ™ierul cu adrese neidentificate self.__table_name = \"point_geometry\" # Denumirea tabelului SpatiaLite (SQLite) self.__header = [self.__quote_identifier( item) for item in next(self.read_csv())] # Denumirile coloanelor self.__not_found_count = 0 # Cantitatea adreselor neidentificate self.exception = None # ExcepÈ›ia returnatÄƒ Ã®n urma geocodificÄƒrii ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:5:0","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Lucrul cu fiÈ™ierul de intrare È™i cel ce conÈ›ine adrese neidentificate ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:6:0","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Citirea fiÈ™ierului de intrare Pentru citirea fiÈ™ierului de intrare, care trebuie sÄƒ fie de tip CSV cu codificarea UTF-8, eu am creat o metodÄƒ care va citi rÃ¢nd cu rÃ¢nd acest fiÈ™ier, iar Ã®n caz cÄƒ va surveni o excepÈ›ie, aceasta va fi afiÈ™atÄƒ Ã®n bara de mesaje ale aplicaÈ›iei geospaÈ›iale QGIS. def read_csv(self): \"\"\" Read CSV file. \"\"\" try: with open(self.__input_filename, 'r', encoding='utf-8') as csvfile: # Identify CSV dialect (delimiter) dialect = csv.Sniffer().sniff(csvfile.read(4096)) csvfile.seek(0) reader = csv.reader(csvfile, dialect) for row in reader: yield row except IOError: iface.messageBar().pushCritical( \"Input CSV File\", \"Failure opening \" + self.__input_filename) except UnicodeDecodeError: iface.messageBar().pushCritical( \"Input CSV File\", \"Bad CSV file - Unicode decode error\") except csv.Error: iface.messageBar().pushCritical( \"Input CSV File\", \"Bad CSV file - verify that your delimiters are consistent\") ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:6:1","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Calcularea numÄƒrului de rÃ¢nduri ale fiÈ™ierului de intrare Pentru ca Ã®n aplicaÈ›ia QGIS sÄƒ fie afiÈ™at procentajul de Ã®ndeplinirii a sarcinii de geocodificare, eu am creat o metodÄƒ pentru calcularea numÄƒrului de rÃ¢nduri ale fiÈ™ierului de intrare de tip CSV. def __count_csv_lines(self): \"\"\" Count CSV lines. \"\"\" try: with open(self.__input_filename, 'r', encoding='utf-8') as csvfile: return sum(1 for row in csvfile) except csv.Error: iface.messageBar().pushCritical( \"Input CSV File\", \"Bad CSV file - verify that your delimiters are consistent\") ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:6:2","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Scrierea rÃ¢ndurilor cu adrese neidentificate Ã®n fiÈ™ier CSV Ãn caz cÄƒ adresele indicate Ã®n fiÈ™ierul de intrare nu au fost posibil de geocodificat, extensia datÄƒ copie Ã®ntregul rÃ¢nd ce conÈ›ine adresa neidentificatÄƒ Ã®n fiÈ™ierul de ieÈ™ire care, la fel, reprezintÄƒ un fiÈ™ier CSV cu codificarea UTF-8 È™i incrementeazÄƒ numÄƒrul de adrese neidentificate care la final de process va fi afiÈ™at Ã®n aplicaÈ›ia QGIS. def __write_notfound_street_to_csv(self, row): \"\"\" Write not found street to CSV file. param line: Line to be written in CSV file. type line: str \"\"\" with open(self.__notfound_filename, mode='a', newline='') as csvfile: csv_writter = csv.writer( csvfile, delimiter=',', quotechar='\"', quoting=csv.QUOTE_MINIMAL) csv_writter.writerow(row) self.__not_found_count += 1 # Increment pentru cantitatea adreselor neidentificate # Se expediazÄƒ cÄƒtre aplicaÈ›ia QGIS log cÄƒ adresa nu a fost identificatÄƒ. QgsMessageLog.logMessage( \"Nu a fost geocodificat rÃ¢ndul CSV: %s\" % ','.join(row), level=Qgis.Warning) ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:6:3","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Utilizarea serviciului API Geocodificare al site-ului Map.md Pentru a utiliza serviciul API Geocodificare al site-ului Map.md API, este nevoie de a obÈ›ine cheia API ğŸ”‘. ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:7:0","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"ObÈ›inerea cheii API Pentru a utiliza serviciul API Geocodificare, este necesar de obÈ›inut un cod unic de identificare. Pentru aceasta, este necesar sÄƒ ne conectÄƒm la sistemul Simpals-ID, utilizÃ¢nd login-ul sau parola contului pentru oricare dintre proiectele companiei. Apoi, accesÄƒm link-ul map.md/ro/api, facem click pe butonul ObÈ›ineÈ›i codul, completÄƒm formularul special È™i salvÄƒm codul rezultat. InformaÈ›ia detailatÄƒ privind obÈ›inerea cheii API o puteÈ›i gÄƒsi Ã®n acest articol. ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:7:1","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Implementarea metodelor destinate adresÄƒrii cÄƒtre Map.md API Pentru a geocodifica adresele conÈ›inute Ã®n fiÈ™ierul de intrare, eu am realizat 3 metode care vor rÄƒspunde de: cÄƒutarea È™i obÈ›inerea identificatorului strÄƒzii; obÈ›inerea datelor geospaÈ›iale ale strÄƒzii; È™i obÈ›inerea datelor geospaÈ›iale ale strÄƒzii cu numÄƒrul casei indicat. def __map_md_search_street(self, row, street): \"\"\" Map.md search street method. param row: Row list. type row: list of str param street: Street. type street: str :return: False or JSON :rtype: dict of str \"\"\" # Se obÈ›ine denumirea localitÄƒÈ›ii din rÃ¢ndul CSV. locality = row[self.__locality_index] # Se face cerere cÄƒtre Map.md API, pentru a obÈ›ine # identificatorul strÄƒzii. r = requests.get( \"https://map.md/api/companies/webmap/search_street?\" + \"location=%s\u0026q=%s\" % (urllib.parse.quote(locality), urllib.parse.quote(street)), auth=(self.__api_key, \"\")) # DacÄƒ nu a fost gÄƒsitÄƒ strada sau a fost returnatÄƒ o eroare, # rÃ¢ndul se scrie Ã®n fiÈ™ierul cu adrese neidentificate È™i # metoda returneazÄƒ False. if not r or not r.json(): self.__write_notfound_street_to_csv(row) return False return r.json() def __map_md_get_street(self, street_id, row): \"\"\" Map.md get street method. param street_id: The Map.md street id. type street_id: int param row: Row list. type row: list of str :return: False or JSON :rtype: dict of str \"\"\" # Se obÈ›ine denumirea localitÄƒÈ›ii din rÃ¢ndul CSV. locality = row[self.__locality_index] # Se face cerere cÄƒtre Map.md API, pentru a obÈ›ine datele # geospaÈ›iale ale strÄƒzii. r = requests.get( \"https://map.md/api/companies/webmap/get_street?\" + \"id=%s\u0026location=%s\" % (urllib.parse.quote(street_id), urllib.parse.quote(locality)), auth=(self.__api_key, \"\")) # DacÄƒ nu a fost gÄƒsitÄƒ strada sau a fost returnatÄƒ o eroare, # rÃ¢ndul se scrie Ã®n fiÈ™ierul cu adrese neidentificate È™i # metoda returneazÄƒ False. if not r or not r.json(): self.__write_notfound_street_to_csv(row) return False return r.json() def __map_md_search_street_with_house_number(self, row, street_id, house_number): \"\"\" Map.md search street with house number method. param row: Row list. type row: list of str param house_number: House number. type house_number: str :return: False or JSON :rtype: dict of str \"\"\" # Se face cerere cÄƒtre Map.md API, pentru a obÈ›ine datele # geospaÈ›iale ale strÄƒzii È™i numÄƒrului casei. r = requests.get( \"https://map.md/api/companies/webmap/get_street?\" + \"id=%s\u0026number=%s\" % (urllib.parse.quote(street_id), urllib.parse.quote(house_number)), auth=(self.__api_key, \"\")) # DacÄƒ nu a fost gÄƒsitÄƒ strada È™i numÄƒrul casei sau a fost # returnatÄƒ o eroare, rÃ¢ndul se scrie Ã®n fiÈ™ierul cu adrese # neidentificate È™i metoda returneazÄƒ False. if not r or not r.json(): self.__write_notfound_street_to_csv(row) return False return r.json() ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:7:2","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Utilizarea bazei de date SpatiaLite pentru stocarea adreselor geocodificate ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:8:0","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"De ce SpatiaLite Extensia MMQGIS, care a servit drept sursÄƒ de inspiraÈ›ie, salveazÄƒ adresele geocodificate Ã®ntr-un fiÈ™ier (ba chiar Ã®n mai multe ğŸ˜) cu extensia ShapeFile (*.shp). AceastÄƒ metodÄƒ de a salva adresele geocodificate nu este favorabilÄƒ deoarece acest tip de fiÈ™ier are urmÄƒtoarele limite È™i dezavantaje: Lungimea denumirii coloanelor nu poate depÄƒÈ™i 10 caractere; Suport slab a codificÄƒrii Unicode; Pe lÃ¢ngÄƒ fiÈ™ierul cu extensia_.shp_, Ã®n aceeaÈ™i mapÄƒ se mai stocheazÄƒ È™i alte fiÈ™iere cu diverse extensii (_.dbf_, *.prj, *.qpj, *.shx, etc.). OperÃ¢nd adesea cu date geospaÈ›iale, Ã®n ultimul timp le salvam, prin intermediul aplicaÈ›iei QGIS, Ã®n baze de date de tip SpatiaLite, care reprezintÄƒ nu altceva, decÃ¢t baze de date de tip SQLite cu date geospaÈ›iale. AplicaÈ›ia QGIS permite de a manipula aceste baze de date, salvÃ¢nd o mulÈ›ime de straturi ale aplicaÈ›iei Ã®ntr-un singur fiÈ™ier. Super! E ceea de ce am nevoie! ğŸ¤— Problema consta Ã®n aceea, cÄƒ cu baze de date de tip SQL reuÈ™isem sÄƒ operez la un nivel superficial, Ã®nsÄƒ nu aveam idee cum sÄƒ proiectez baze de date de tip SpatiaLite. NavigÃ¢nd pe Internet am gÄƒsit urmÄƒtoarea serie de articole care explicÄƒ clar cum funcÈ›ioneazÄƒ aceastÄƒ bazÄƒ de date. Minunat! E timpul pentru experimente ğŸ§ªğŸ’¡. ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:8:1","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Structura bazei de date SpatiaLite Baza de date de tip SpatiaLite trebuie sÄƒ conÈ›inÄƒ un tabel destinat pentru salvarea datelor geospaÈ›iale ğŸŒ. Baza de date È™i tabelul vor fi create la Ã®nceputul geocodificÄƒrii adreselor, adÄƒugÃ¢ndu-se coloanele tabelului Ã®n strictÄƒ corespundere cu coloanele din fiÈ™ierul de intrare de tip CSV. Ulterior, se mai adaugÄƒ o coloanÄƒ ce conÈ›ine date geospaÈ›iale, Ã®n cazul dat, de tip Point cu geoproiecÈ›ia WGS84 (4326) ğŸŒ. La final, este necesar de creat index pentru cheia primarÄƒ È™i pentru coloana cu date geospaÈ›iale, pentru a Ã®mbunÄƒtÄƒÈ›i performanÈ›a bazei de date ğŸ“ˆ. ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:8:2","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Proiectarea bazei de date SpatiaLite Modalitatea de iniÈ›iere a bazei de date, creÄƒrii tabelului pentru adrese geocodificate È™i a index-urilor este indicatÄƒ Ã®n metoda de mai jos. def __init_spatialite_db(self): \"\"\" Init SpatiaLite database.\"\"\" with sqlite3.connect(self.__output_filename) as conn: conn.enable_load_extension(True) conn.load_extension(\"mod_spatialite\") conn.execute(\"SELECT InitSpatialMetaData(1);\") conn.execute(\"\"\"CREATE TABLE IF NOT EXISTS %s ( PointId INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT);\"\"\" % self.__table_name) conn.execute(\"\"\"CREATE UNIQUE INDEX IF NOT EXISTS idx_%s_id ON %s (PointId);\"\"\" % (self.__table_name, self.__table_name)) cur = conn.cursor() cur.execute(\"PRAGMA table_info('%s');\" % self.__table_name) db_columns = cur.fetchall() db_columns = (x[1] for x in db_columns) db_columns = [self.__quote_identifier(x) for x in db_columns] for column in self.__header: # Se adauga coloanele care nu au existat anterior if column not in db_columns: conn.execute(\"\"\"ALTER TABLE %s ADD COLUMN %s TEXT\"\"\" % (self.__table_name, column)) # Se adauga coloana ce contine date geospatiale # cu geoproiectia WSG 84 (4326) if \"Geometry\" not in db_columns: conn.execute( \"\"\"SELECT AddGeometryColumn( 'point_geometry', 'Geometry', 4326, 'POINT', 'XY');\"\"\") # Se adauga index geospatial conn.execute( \"SELECT CreateSpatialIndex('point_geometry', 'Geometry');\") Ãn fragmentul de cod ce urmeazÄƒ, este realizatÄƒ funcÈ›ionalitatea de adÄƒugare a rÃ¢ndului CSV, ce a fost geocodificat cu succes, Ã®n tabelul bazei de date SpatiaLite È™i adÄƒugarea coordinatelor punctului unde este localizatÄƒ adresa sau intersecÈ›ia. def __add_row_to_db(self, row, geometry): \"\"\" Add CSV row to database. param csv_row: CSV row. type csv_row: list of str param geometry: Point geometry. type geometry: str \"\"\" with sqlite3.connect(self.__output_filename) as conn: conn.enable_load_extension(True) conn.load_extension(\"mod_spatialite\") cur = conn.cursor() # Insert it. sql = \"\"\"INSERT INTO point_geometry (%s, Geometry) VALUES (%s, GeomFromText('%s', 4326));\"\"\" % \\ ( ','.join(self.__header), ','.join([self.__quote_identifier(item) for item in row]), geometry ) cur.execute(sql) ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:8:3","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Implementarea procesului de geocodificare propriu-zis Extensia pe care am creato va implementa 4 tipuri de geocodificÄƒri, dupÄƒ cum urmeazÄƒ: Geocodificarea strÄƒzii, numÄƒrului casei È™i localitÄƒÈ›ii; Geocodificarea strÄƒzii È™i localitÄƒÈ›ii, cÃ¢nd numÄƒrul casei se conÈ›ine Ã®n cÃ¢mpul cu stradÄƒ; Geocodificarea intersecÈ›iilor (strada1, strada2, localitate); Geocodificarea combinatÄƒ (se alege una din cele menÈ›ionate mai sus, Ã®n dependenÈ›Äƒ de ce cÃ¢mpuri Ã®n fiÈ™ierul CSV sunt suplinite). ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:9:0","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Implementarea metodelor de geocodificare a rÃ¢ndurilor CSV Ãn urmÄƒtoarele fragmente de cod, eu am implementat 2 metode ce vor geocodifica strada È™i numÄƒrul casei È™i, respectiv, intersecÈ›ia a douÄƒ strÄƒzi. Aceste metode vor apela la metodele create anterior care comunicÄƒ cu serviciul API Geocodificare al site-ului Map.md. def __geocode_street_and_house_number(self, row, street, house_number): \"\"\" Geocode street1 and house number. param row: Row list. type row: list of str param street: Street. type street: str param house_number: House number. type house_number: str :return: Return bool. :rtype: bool \"\"\" r = self.__map_md_search_street(row, street) if not r: return False # Se obtine lista cu numerele caselor adresei solicitate buildings = r[0]['buildings'] # Daca numarul casei nu se gaseste in lista, # nu se indeplineste cel de-al doilea request if house_number not in buildings: self.__write_notfound_street_to_csv(row) return False r = self.__map_md_search_street_with_house_number( row, r[0]['id'], house_number) if not r: return False geometry = \"POINT(%s %s)\" % (r['point']['lon'], r['point']['lat']) self.__add_row_to_db(row, geometry) def __geocode_street1_and_street2(self, row, street1, street2): \"\"\" Geocode street1 and street2. param row: Row list. type row: list of str param street: Street1. type street: str param street: Street2. type street: str :return: Return bool. :rtype: bool \"\"\" # Se cauta strada1 pentru a obtine identificatorul ei r1 = self.__map_md_search_street(row, street1) # Se cauta strada2 pentru a obtine identificatorul ei r2 = self.__map_md_search_street(row, street2) # Verificare strada1 si strada2 if not r1 or not r2: return False # Se obtine datele despre strada1 si strada2 r1 = self.__map_md_get_street(r1[0]['id'], row) r2 = self.__map_md_get_street(r2[0]['id'], row) if not r1 or not r2: return False r1_geo_json = r1['geo_json'] r2_geo_json = r2['geo_json'] s1 = shape(r1_geo_json) s2 = shape(r2_geo_json) if not s1.intersects(s2): self.__write_notfound_street_to_csv(row) return False geometry = s1.intersection(s2) # In cazul ca se identifica MultiPoint, # se ia primul Point in consideratie if isinstance(geometry, shapely.geometry.multipoint.MultiPoint): geometry = geometry[0] self.__add_row_to_db(row, geometry.wkt) ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:9:1","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Implementarea metodei de rulare a procesului de geocodificare Pentru a rula procesul de geocodificare, instrucÈ›iunile destinate acestui scop au fost plasate Ã®n metoda run, din motiv cÄƒ managerul de sarcini al aplicaÈ›iei QGIS apeleazÄƒ anume aceastÄƒ metodÄƒ cÃ¢nd se adaugÄƒ o sarcinÄƒ nouÄƒ Ã®n acesta (metoda addTask). def run(self): \"\"\" Geocode addresses using Map.md API. return: Return bool type. type: bool \"\"\" QgsMessageLog.logMessage(\"Ãnceput geocodificare.\", level=Qgis.Info) # Se initializeaza baza de date SpatiaLite self.__init_spatialite_db() pattern = r\"^((?:[a-z0-9ÄƒÃ®È™È›Ã¢]+[\\., ]+)+)(\\d{1,3}(?:[\\/ ]?\\w{1,2})?)$\" if self.__street1_index == -1 and self.__locality_index == -1: self.exception = Exception( \"Indicele cÃ¢mpurilor street1 È™i/sau locality sunt goale!\") # Se omite primul rand, deoarece contine denumirile coloanelor iter_rows = iter(self.read_csv()) next(iter_rows) for index, row in enumerate(iter_rows): self.setProgress(index*100/self.__count_csv_lines()) # verificÄƒ isCanceled() pentru a gestiona anularea geocodificÄƒrii if self.isCanceled(): return False if not row[self.__street1_index] and \\ not row[self.__locality_index]: self.__write_notfound_street_to_csv(row) elif self.__street2_index \u003e -1 and \\ row[self.__street2_index]: QgsMessageLog.\\ logMessage(\"Street1 + Street2 + Locality\", level=Qgis.Info) geocode_street1_and_street2 = \\ self.__geocode_street1_and_street2( row, row[self.__street1_index], row[self.__street2_index]) if not geocode_street1_and_street2: continue elif self.__house_number_index \u003e -1 and \\ row[self.__house_number_index]: QgsMessageLog.\\ logMessage(\"Street1 + House number + Locality\", level=Qgis.Info) geocode_street_and_house_number = \\ self.__geocode_street_and_house_number( row, row[self.__street1_index], row[self.__house_number_index]) if not geocode_street_and_house_number: continue else: QgsMessageLog.logMessage(\"Street1 + Locality\", level=Qgis.Info) match = re.search(pattern, row[self.__street1_index], re.IGNORECASE | re.UNICODE) if not match: self.__write_notfound_street_to_csv(row) continue street = match.group(1).replace(',', '').strip() house_number = match.group(2).strip() geocode_street_and_house_number = \\ self.__geocode_street_and_house_number( row, street, house_number) if not geocode_street_and_house_number: continue return True ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:9:2","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Implementarea metodei de finisare a procesului de geocodificare Clasa QgsTask mai implementeazÄƒ o metodÄƒ denumitÄƒ finished, care va fi apelatÄƒ dupÄƒ finalizarea sarcinii (fie prin finalizare cu succes, fie prin anulare la cererea utilizatorului). Argumentul result reflectÄƒ dacÄƒ sarcina a fost finalizatÄƒ cu succes sau nu. AceastÄƒ metodÄƒ este Ã®ntotdeauna apelatÄƒ de la thread-ul principal, deci se permite de a adÄƒuga stratul cu puncte geocodificate Ã®n aplicaÈ›ie. def finished(self, result): \"\"\" This function is automatically called when the task has completed (successfully or not). You implement finished() to do whatever follow-up stuff should happen after the task is complete. finished is always called from the main thread, so it's safe to do GUI operations and raise Python exceptions here. result is the return value from self.run. \"\"\" if result: # Se adauga stratul in QGIS self.__add_spatialite_layer_to_qgis() csv_row_count = self.__count_csv_lines() QgsMessageLog.logMessage( \"SfÃ¢rÈ™it geocodificare.\" + \"Au fost geocodificate %i din %i adrese.\" % (csv_row_count-self.__not_found_count, csv_row_count), level=Qgis.Success) elif self.exception is None: # Se adauga stratul in QGIS self.__add_spatialite_layer_to_qgis() QgsMessageLog.logMessage( \"Geocodificarea a fost anulatÄƒ. \" + \"Se afiÈ™eazÄƒ rezultatele obÈ›inute pÃ¢nÄƒ la moment.\", level=Qgis.Warning) else: QgsMessageLog.logMessage( \"Procesul de geocodificare a returnat o excepÈ›ie:\\n%s\" % str(self.exception), level=Qgis.Critical) raise self.exception ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:9:3","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Implementarea logicii pentru interfaÈ›a dialogul de geocodificare InterfaÈ›a dialogului extensiei creatÄƒ anterior este lipsitÄƒ de un oarecare funcÈ›ional, cu alte cuvinte nu implementeazÄƒ nici-o logicÄƒ. E timpul sÄƒ reparÄƒm acest lucru ğŸ¤—. ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:10:0","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Importarea bibliotecilor necesare Ãn primul rÃ¢nd, ne asigurÄƒm cÄƒ am importat tot de ce vom avea nevoie pe parcurs: import os from PyQt5 import uic from PyQt5 import QtWidgets from PyQt5.QtWidgets import QFileDialog, QDialogButtonBox from .map_md_utils import MapMdUtils ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:10:1","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Asigurarea conexiunii evenimentelor cu metodele respective Ulterior, la constructorul clasei MapMdDialog, implementÄƒm conexiunile evenimentelor de modificare a textului, de apÄƒsare click pe butoane cu metodele corespunzÄƒtoare. self.button_box.button(QDialogButtonBox.Ok).setEnabled(False) # ConectÄƒm evenimentele de modificare a textului cu metoda ce va # activa butonul OK. self.input_filename.textChanged.connect(self.is_ready_to_geocode) self.output_spatialite_filename.textChanged.connect(self.is_ready_to_geocode) self.output_notfound_filename.textChanged.connect(self.is_ready_to_geocode) self.api_key.textChanged.connect(self.is_ready_to_geocode) self.street_field1.currentTextChanged.connect(self.is_ready_to_geocode) self.locality_field.currentTextChanged.connect(self.is_ready_to_geocode) # Conectarea evenimentelor click pe butoane cu metodele ce vor # afiÈ™a dialoguri de deschidere/salvare a fiÈ™ierelor. self.browse_infile.clicked.connect(self.browse_infile_dialog) self.browse_spatialite.clicked.connect(self.browse_spatialite_file_dialog) self.browse_notfound.clicked.connect(self.browse_notfound_file_dialog) ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:10:2","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Implementarea metodei de alegere a fiÈ™ierului de intrare Ãn fragmentul de cod ce urmeazÄƒ, este implementat funcÈ›ionalul de alegere a fiÈ™ierului de intrare de tip CSV UTF-8. Pentru aceasta, dupÄƒ apÄƒsarea click pe primul buton Browseâ€¦, se va afiÈ™a dialogul de deschidere a fiÈ™ierului. DupÄƒ alegerea fiÈ™ierului de intrare, Ã®n cÃ¢mpul fiÈ™ierului de ieÈ™ire se va salva calea absolutÄƒ a fiÈ™ierului de intrare, aceeaÈ™i denumire ca È™i fiÈ™ierul de intrare + extensia .db, iar Ã®n cÃ¢mpul fiÈ™ierului cu adrese neidentificate â€“ calea absolutÄƒ a fiÈ™ierului de intrare cu denumirea fiÈ™ierului notfound.csv. DupÄƒ aceasta, toate elementele combobox vor fi suplinite cu denumirile coloanelor fiÈ™ierului de intrare, pentru a permite utilizatorului de a asocia cÃ¢mpurile extensiei cu coloanele din fiÈ™ierul de intrare. def browse_infile_dialog(self): \"\"\" Browse input CSV file dialog \"\"\" input_file_name, _ = QFileDialog.getOpenFileName( None, \"Address CSV Input File\", self.input_filename.displayText(), \"CSV File (*.csv *.txt)\") if input_file_name and len(input_file_name) \u003e 4: abspath = os.path.abspath(input_file_name) # Se seteaza calea fisierului de intrare self.input_filename.setText(abspath) # Se seteaza calea spre fisierul de iesire (SpatiaLite) # Se inlocuieste extensia '.csv' cu '.db' self.output_spatialite_filename.setText( os.path.join( os.path.dirname(abspath), os.path.splitext( os.path.basename(abspath))[0] + '.db')) # Se seteaza calea spre fisierul CSV cu adrese neidentificate self.output_notfound_filename.setText( os.path.join(os.path.dirname(abspath), 'notfound.csv')) combolist = [self.street_field1, self.street_field2, self.house_number_field, self.locality_field] for box in combolist: box.clear() box.addItem(\"(none)\") box.setCurrentIndex(0) map_md_utils = MapMdUtils( self.input_filename.displayText()) try: header = next(map_md_utils.read_csv()) header = [field for field in header] if header is None: return for index in header: for box in combolist: box.addItem(index) except StopIteration: pass ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:10:3","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Implementarea metodei de alegere a cÄƒilor spre fiÈ™ierele de ieÈ™ire Cum am menÈ›ionat anterior, dupÄƒ alegerea fiÈ™ierului de intrare, Ã®n mod implicit se modificÄƒ È™i calea spre fiÈ™ierele de ieÈ™ire È™i a celui ce conÈ›ine adrese neidentificate, Ã®nsÄƒ aceste cÄƒi (precum È™i denumirea fiÈ™ierelor) pot fi modificate la cererea utilizatorului, apÄƒsÃ¢nd pe butoanele Browseâ€¦ Ã®n drept cu cÃ¢mpurile menÈ›ionate. def browse_spatialite_file_dialog(self): \"\"\" Browse SpatiaLite file dialog. \"\"\" output_file_name, _ = QFileDialog.getSaveFileName( None, \"Output SpatiaLite File\", self.output_spatialite_filename.displayText(), \"SpatiaLite File (*.db *.sqlite)\") if output_file_name: self.output_spatialite_filename.setText( os.path.abspath(output_file_name)) def browse_notfound_file_dialog(self): \"\"\" Browse Not Found file dialog. \"\"\" output_file_name, _ = QFileDialog.getSaveFileName( None, \"Output Not Found File\", self.output_notfound_filename.displayText(), \"CSV File (*.csv *.txt)\") if output_file_name: self.output_notfound_filename.setText( os.path.abspath(output_file_name)) ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:10:4","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Verificarea disponibilitÄƒÈ›ii procedurii de geocodificare CÃ¢mpul cu calea spre fiÈ™ierul de intrare sÄƒ nu fie gol; CÃ¢mpul cu calea spre fiÈ™ierul de ieÈ™ire sÄƒ nu fie gol; CÃ¢mpul cu cheia API sÄƒ nu fie gol; Componentul combobox cu denumirea Street 1 field sÄƒ nu fie gol; Componentul combobox cu denumirea Locality field sÄƒ nu fie gol. DupÄƒ satisfacerea acestor condiÈ›ii, butonul OK al interfeÈ›ei dialogului extensiei va fi pornit È™i va fi posibil de apÄƒsat. def is_ready_to_geocode(self): \"\"\" Enable or disable OK button whether all required field are filled. \"\"\" is_ready = self.input_filename.displayText() \\ and self.output_spatialite_filename.displayText() \\ and self.output_notfound_filename.displayText() \\ and self.api_key.displayText() \\ and self.street_field1.currentIndex() \u003e 0 \\ and self.locality_field.currentIndex() \u003e 0 self.button_box.button(QDialogButtonBox.Ok).setEnabled( bool(is_ready)) ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:10:5","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Modificarea fiÈ™ierului principal al extensiei Ãn fiÈ™ierul map_md.py ne asigurÄƒm cÄƒ am importat urmÄƒtoarele biblioteci: import os.path from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication from PyQt5.QtGui import QIcon from PyQt5.QtWidgets import QAction from qgis.core import QgsApplication, QgsMessageLog from .resources import * from .map_md_dialog import MapMdDialog from .map_md_utils import MapMdUtils ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:11:0","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"ObÈ›inerea datelor din interfaÈ›a dialogului extensiei È™i adÄƒugarea procesului de geocodificare Ã®n managerul de sarcini Ãn constructorul clasei MapMd, atribuim o variabilÄƒ care va obÈ›ine obiectul managerului de sarcini al aplicaÈ›iei QGIS. self.task_manager = QgsApplication.taskManager() Ulterior, dacÄƒ a fost apÄƒsat butonul OK din interfaÈ›a dialogului extensiei, atunci se obÈ›ine toÈ›i parametrii setaÈ›i Ã®n aceasta, se creazÄƒ o nouÄƒ instanÈ›Äƒ a clasei MapMdUtils, care extinde clasa QgsTask È™i o transmite metodei addTask a obiectului taskManager. if result: # Init variables api_key = self.dlg.api_key.displayText() street1_index = self.dlg.street_field1.currentIndex() - 1 street2_index = self.dlg.street_field2.currentIndex() - 1 house_number_index = self.dlg.house_number_field.currentIndex() - 1 locality_index = self.dlg.locality_field.currentIndex() - 1 input_filename = self.dlg.input_filename.displayText() output_filename = self.dlg.output_spatialite_filename.displayText() notfound_filename = self.dlg.output_notfound_filename.displayText() map_md_utils = MapMdUtils(input_filename, output_filename, notfound_filename, api_key, street1_index, street2_index, house_number_index, locality_index, ) # Geocoding CSV rows task_id = self.task_manager.addTask(map_md_utils) QgsMessageLog.logMessage(\"AtribuitÄƒ sarcinÄƒ nr. %s\" % str(task_id)) ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:11:1","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Ãncheire La primele testÄƒri, aceastÄƒ extensie funcÈ›ioneazÄƒ bine. Extensia o puteÈ›i gÄƒsi pe depozitul Plugin-urilor QGIS sau pe repository oficial Github ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:12:0","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"}]