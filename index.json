[{"categories":["Proiecte"],"content":"În acest articol, vom pune în discuție contruirea și animarea evolventei unui cerc, curba care se obține prin desfășurarea imaginară de pe mosor sau înfășurarea pe mosor a unei ațe cu condiția ținerii acesteia permanent întinsă.","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea și animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"1. Introducere Salutare tuturor! 🙋‍♂️ În acest articol vom pune în discuție construirea și animarea evolventei unui cerc. Evolventa, vorbind cu un limbaj simplu, este o curbă care se obține prin desfășurarea imaginară de pe mosor sau înfășurarea pe mosor a unei ațe cu condiția ținerii acesteia permanent întinsă. Evolventa este parte a profilului dintelui unei roți dințate folosite la transmisii prin angrenaje. Profilul evolventic asigură un raport de transmitere constant între roțile dințate, randament ridicat, precum și alte avantaje. Raportul de transmitere constat între 2 roți dințate cu profil evolventic. Credits: Wikipedia Proiectarea evolventei o vom realiza cu ajutorul LaTeX, sistemul de preparare a documentelor ce se folosește pe larg în mediul academic. Demonstrare grafică cum evolventa funcționează. $\\LaTeX$ este bine cunoscut pentru abilitatea sa de lucru cu texte matematice, științifice și alte lucrări complexe: documente lungi sau complicate, precum și cele multilingve. Sistemele $\\TeX$ produc rezultatul pe hârtie sau pe ecranul computerului cu cea mai înaltă calitate tipografică. Această calitate este crucială pentru textele complexe, unde capacitatea cititorului de a înțelege materialul depinde de claritatea cu care acesta este prezentat 1. Codul complet al proiectării evolventei unui cerc îl găsiți mai jos sau pe repository-ul Github. În continuare vom explica mai detaliat utilitatea fiecărei secțiuni de cod. \\documentclass[tikz,border=10pt]{standalone} \\usepackage{pgfplots,amsmath} \\pgfplotsset{compat=newest} \\begin{document} \\pgfmathsetmacro\\radius{2} % Colors \\definecolor{tangentLineColor}{HTML}{BC5090} \\definecolor{remainingArcColor}{HTML}{003F5C} \\definecolor{involuteSplineColor}{HTML}{58508D} \\definecolor{accentColor}{HTML}{FF6361} \\colorlet{dashedLineColor}{black} % Styles \\tikzstyle{information text}=[fill=red!10,inner sep=1ex] \\pgfplotsset{ /pgf/number format/textnumber/.style={ fixed, fixed zerofill, precision=2, 1000 sep={,}, }, } \\foreach \\rollAngle in {0.05,0.1,...,3.25} { \\begin{tikzpicture} [ point/.style = {draw, circle, fill = black, inner sep = 1pt}, dot/.style = {draw, circle, fill = black, inner sep = .2pt}, declare function = { involutex(\\radius,\\psi) = \\radius * (cos(\\psi) + \\psi * sin(\\psi)); involutey(\\radius,\\psi) = \\radius * (sin(\\psi) - \\psi * cos(\\psi)); arcx(\\radius,\\a,\\psi) = \\a + \\radius * cos(\\psi); arcy(\\radius,\\b,\\psi) = \\b + \\radius * sin(\\psi); }, ] \\pgfmathsetmacro\\rollAngleDeg{deg(\\rollAngle)} \\pgfmathsetmacro\\arcLength{0.5 * \\rollAngle * \\radius^2} \\pgfmathsetmacro\\curvature{1 / (\\radius * \\rollAngle)} \\begin{axis}[ name=plotAxis, trig format=rad, axis equal, axis lines=center, grid=both, xlabel=$x$, ylabel=$y$, xmin=-5,xmax=5, ymin=-3,ymax=7, xticklabels=\\empty, yticklabels=\\empty, ] \\coordinate (O) at (0,0); \\coordinate (Or) at (\\radius,0); \\coordinate (L1) at ({arcx(\\radius,0,\\rollAngle)},{arcy(\\radius,0,\\rollAngle)}); \\coordinate (L2) at ({involutex(\\radius,\\rollAngle)},{involutey(\\radius,\\rollAngle)}); \\addplot [domain=2*pi:\\rollAngle,samples=200,remainingArcColor,thick,line cap=round]({arcx(\\radius,0,x)},{arcy(\\radius,0,x)}); \\addplot [domain=0:\\rollAngle,samples=200,dashedLineColor,dashed,line cap=round]({arcx(\\radius,0,x)},{arcy(\\radius,0,x)}); \\addplot [domain=0.01:\\rollAngle,samples=200,involuteSplineColor,thick,line cap=round]({involutex(\\radius,x)},{involutey(\\radius,x)}); \\draw[tangentLineColor,thick] (L1) -- (L2); \\draw[dashedLineColor,dashed] (O) -- (L1) node [accentColor,pos=0.5,sloped,above] {$r$}; \\addplot [domain=0:\\rollAngle,samples=200,accentColor,line cap=round]({arcx(.4,0,x)},{arcy(.4,0,x)}) node[] at (.5, -.3) {$\\psi$}; \\end{axis} \\node [xshift=.5cm,below right,align=center,text width=6cm,style=information text] at (plotAxis.north east) { This is a demonstration how the {\\color{accentColor} involute of a circle} works. So, {\\color{accentColor} $r$} is radius of the circle, {\\color{accentColor} $\\psi$} --- roll angle, {\\color{accentColor} $L$} --- ar","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:1:0","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea și animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"2. Setarea mediului de dezvoltare Pentru development, vom folosi aplicația gratuită Visual Studio Code în calitate de editor de cod sursă și vom crea container Docker, în interiorul căruia vom instala și configura toate pachetele necesare pentru lucru. Cu ajutorul editorului Visual Studio Code putem să facem development chiar în interiorul containerului 💡. Cum se configurează devcontainers puteți citi în acest articol. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:2:0","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea și animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"2.1. Configurarea Dockerfile Docker poate construi în mod automat imagini citind instrucțiunile dintr-un fișier Dockerfile. Un fișier Dockerfile este un document text care conține toate comenzile pe care un utilizator le-ar putea apela din linia de comandă pentru a asambla o imagine 2. În scopul efectuării development-ului, vom folosi imaginea de bază blang/latex. Acesta va instala, compila și configura LaTeX. Astfel, vom avea toate pachetele LaTeX instalate în devcontainer-ul nostru. Acest fișier îl vom plasa în mapa .devcontainer din proiectul nostru. FROM blang/latex:ubuntu RUN apt update \u0026\u0026 apt install -y graphicsmagick ffmpeg Pe lângă LaTeX, vom mai instala două pachete adiționale care se numesc GraphicsMagick și FFmpeg. Acestea vor servi la convertirea fișierului de ieșire pdf, generat de LaTex, în fișier mp4. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:2:1","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea și animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"2.2. Configurarea devcontainer.json La această etapă, vom crea fișierul devcontainer.json care la fel îl vom plasa în mapa .devcontainer din proiect. Acest fișier este utilizat pentru pentru lansarea (sau atașarea) containerului de dezvoltare (devcontainer). Acest fișier va conține și comanda pentru instalarea in VS Code a extensiei LaTeX Workshop, care are ca funcționalitate completarea automată a codului, syntax highliting, compilarea documentului și multe alte funcționalități. { \"name\": \"LaTeX\", \"dockerFile\": \"Dockerfile\", \"settings\": { \"terminal.integrated.shell.linux\": \"/bin/bash\", \"latex-workshop.latex.watch.usePolling\": true, \"latex-workshop.latex.autoBuild.run\": \"onFileChange\", \"latex-workshop.latex.autoBuild.interval\": 1000, \"latex-workshop.docker.enabled\": false, }, \"extensions\": [ \"james-yu.latex-workshop\", \"adam-bender.commit-message-editor\" ], \"mounts\": [ ], \"remoteEnv\": { } } Dacă au fost efectuate configurările corecte, atunci la pornirea aplicației VS Code și la deschiderea mapei cu proiectul dat, editorul ne va propune să trecem pe devcontainer. Visual Studio Code propune de a deschide mapa în container. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:2:2","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea și animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"3. Structura de bază și preambulul documentului LaTeX Pentru început este necesar de a crea un fișier cu extensia .tex. Toate instrucțiunile necesare pentru construirea evolventei vor fi scrise în acesta. Când $\\LaTeX$ procesează un document, el se așteaptă ca documentul să conțină o anumită structură. Astfel, fiecare document trebuie să conțină comenzile: \\documentclass{...} \\begin{document} ... \\end{document} Între comenzile \\documentclass și \\begin{document} se afla așa numitul preambul. În secțiunea dată se conțin comenzile care vor afecta întregul document LaTeX. Tot aici se importă pachetele necesare și se efectuează careva setări asupra acestora. În cazul nostru, comanda \\documentclass mai conține câteva opțiuni, izolate între paranteze pătrate și mai specifică ce tip de clasă a documentului se va folosi, aceasta fiind izolată între acolade. \\documentclass[tikz,border=10pt]{standalone} ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:3:0","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea și animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"3.1. Clasa și pachetul standalone Clasa standalone este proiectată pentru a crea fragmente individuale de conținut. Această clasă este utilă la generarea imaginilor care vor fi incluse în alte documente 3. Pachetul standalone permite utilizatorilor să plaseze cu ușurință imagini sau alt material în fișierele proprii și să le compileze de sine stătător sau ca parte a unui document principal 4. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:3:1","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea și animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"3.2. Opțiunea și pachetul TikZ Pachetul TikZ este probabil cel mai complex și puternic instrument pentru crearea elementelor grafice în LaTeX. Cu acest pachet putem crea elemente grafice complexe utilizând așa elemente simple, cum ar fi linii, puncte, curbe, cercuri, dreptunghiuri, etc. Pentru imaginile desenate cu TikZ este oferită o opțiune dedicată tikz care încarcă acest pachet și configurează mediul tikzpicture pentru a crea o singură pagină decupată 5. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:3:2","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea și animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"3.3. Opțiunea border Opțiunea border=10pt specifică că documentul va avea un chenar de 10pt sau, cu alte cuvinte, va avea o margine din toate părțile de 10pt. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:3:3","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea și animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"3.4. Importarea pachetelor necesare Distributivele moderne LaTeX vin cu un gama largă de pachete preinstalate. Pentru generarea evolventei ne vom folosi de pachetele pgfplots și amsmath. \\usepackage{pgfplots,amsmath} \\pgfplotsset{compat=newest} Pachetul pgfplots este un instrument puternic, fiind bazat pe TikZ, care este dedicat construirii graficelor științifice. Acest pachet reprezintă un instrument de vizualizare pentru a simplifica includerea graficelor în documente. Ideea de bază este că furnizăm datele/formule și pgfplots face restul 6. Configurarea \\pgfplotsset{compat=newest} ne permite să utilizăm cele mai recente caracteristici ale pachetului pgfplots. Pachetul amsmath îl voi folosi pentru alinierea formulelor matematice, însă funcționalul acestui pachet nu se limitează doar la alinierea formulelor. Cu acest pachet puteți construi matrice, fracții continue (fracții incluse în fracții), formule în chenar și multe altele. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:3:4","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea și animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"4. Definirea variabilelor necesare \\pgfmathsetmacro\\radius{2} % Colors \\definecolor{tangentLineColor}{HTML}{BC5090} \\definecolor{remainingArcColor}{HTML}{003F5C} \\definecolor{involuteSplineColor}{HTML}{58508D} \\definecolor{accentColor}{HTML}{FF6361} \\colorlet{dashedLineColor}{black} % Styles \\tikzstyle{information text}=[fill=red!10,inner sep=1ex] \\pgfplotsset{ /pgf/number format/textnumber/.style={ fixed, fixed zerofill, precision=2, 1000 sep={,}, }, } În secțiunea dată setăm raza cercului. Toate calculele ulterioare for fi în bază de valoarea setată la variabila radius. Ulterior, setăm culorile necesare pentru fiecare strat desenat pe graficul nostru. Aici se folosește pachetul xcolor. Dar de ce nu l-am importat în preambul? Acest pachet nu trebuie în cazul nostru de importat din motiv că tikz deja îl utilizează. Profit 🙂! În ultimele comenzi din această secțiune se setează un stil cu denumirea information text ce va avea 10% intensitate din culoarea roșie și mai setează precizia părții fracționare a calculelor de 2 cifre. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:4:0","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea și animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"5. Construirea graficelor evolventei Ca să construim animația evolventei unui cerc, vom proceda astfel. Prin comanda \\foreach vom desena cadru după cadru câte un grafic unde ca valoare de iterație va fi unghiul de depanare a evolventei. Cu alte cuvinte, în fișierul de ieșire pdf vom avea în fiecare pagină a câte un grafic. \\foreach \\rollAngle in {0.05,0.1,...,3.25} { ... } Pentru construirea evolventei vom folosi radiani în loc de grade. În ciclul foreach vedem că unghiul de depanare începe de la $ \\psi_a = 0.05 rad $ și se termină cu $ \\psi_b = 3.25 rad $. Pasul de la iterație la iterație este de $ \\psi_i = 0.05 rad $. Putem cu aceste date prealabil să calculăm numărul de cadre care vor fi în final. $$ \\frac{\\psi_b - \\psi_a}{\\psi_i} = \\frac{3.25 - 0.05}{0.05} = 64 $$ ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:5:0","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea și animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"5.1. Setări generale ale mediului tikzpicture la fiecare iterație Comenzile de desenare tikz (inclusiv și pgfplots) trebuie să fie incluse într-un mediu tikzpicture. \\begin{tikzpicture} [ declare function = { involutex(\\radius,\\psi) = \\radius * (cos(\\psi) + \\psi * sin(\\psi)); involutey(\\radius,\\psi) = \\radius * (sin(\\psi) - \\psi * cos(\\psi)); arcx(\\radius,\\a,\\psi) = \\a + \\radius * cos(\\psi); arcy(\\radius,\\b,\\psi) = \\b + \\radius * sin(\\psi); }, ] ... \\end{tikzpicture} Ca opțiune a mediului tikzpicture vom determina funcțiile necesare pentru construirea graficelor. În cod vedem 4 funcții însă în realitate merge vorba de doar două, deoarece în pereche acestea alcătuiesc ecuații parametrice. În matematică, o ecuație parametrică definește un grup de cantități ca funcții ale uneia sau mai multor variabile independente numite parametri. Ecuațiile parametrice sunt utilizate în mod obișnuit pentru a exprima coordonatele punctelor care alcătuiesc un obiect geometric, cum ar fi o curbă sau o suprafață, caz în care ecuațiile sunt denumite colectiv reprezentare parametrică sau parametrizare a obiectului 7. Ecuațiile parametrice pentru reprezentarea grafică a evolventei sunt indicate mai jos, unde $r$ este raza cercului și $\\psi$ – unghiul de “depanare a aței de pe mosor” 😄. $$ x = r(\\cos\\psi + \\psi\\sin\\psi) $$ $$ y = r(\\sin\\psi - \\psi\\cos\\psi) $$ Celelalte două ecuații parametrice le vom folosi pentru a desena arcuri de cerc pe grafic, unde $r$ iarăși este raza cercului, $\\psi$ – unghiul arcului de cerc, iar $x_{\\tiny 0}$ și $y_{\\tiny 0}$ sunt coordonatele centrului cercului, în cazul în care acesta nu se află în origine. $$ x = x_{\\tiny 0} + r \\cos\\psi $$ $$ y = y_{\\tiny 0} + r \\sin\\psi $$ ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:5:1","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea și animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"5.2. Adaugarea variabilelor suplimentare La fiecare iterație vor fi efectuate câteva calcule, rezultatele cărora vor fi salvate în variabile. Aceste variabile vor fi utile în continuare pentru afișarea textuală a rezultatelor calculelor. \\pgfmathsetmacro\\rollAngleDeg{deg(\\rollAngle)} \\pgfmathsetmacro\\arcLength{0.5 * \\rollAngle * \\radius^2} \\pgfmathsetmacro\\curvature{1 / (\\radius * \\rollAngle)} Prima variabilă rollAngleDeg va conține valoarea unghiului de depanare exprimată în grade. Ulterior vom salva lungimea arcului evolventei în variabila arcLength. Aceasta are următoarea formulă: $$ L = \\frac{1}{2} \\psi r^2 $$ În final, vom calcula curbarea și vom salva valoarea acesteia în variabila curvature. Formula pentru calcularea acesteia este următoarea: $$ \\kappa = \\frac{1}{\\psi r} $$ ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:5:2","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea și animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"5.3. Setări generale ale axelor graficului fiecărui cadru Declarația de mediu \\begin {axis} și \\end {axis} va seta scalarea corectă a graficului. Noi vom folosi scalarea simplă liniară, însă acest pachet are și alte tipuri de scalări, pe care le puteți folosi la proiectarea altor grafice. \\begin{axis}[ name=plotAxis, trig format=rad, axis equal, axis lines=center, grid=both, xlabel=$x$, ylabel=$y$, xmin=-5,xmax=5, ymin=-3,ymax=7, xticklabels=\\empty, yticklabels=\\empty, ] ... \\end{axis} După cum observăm, axele au un șir de opțiuni atribuite. În mod succint vom desfășura semnificația și utilitatea acestora. Grafic cu axe localizate în centru, scalare liniară. 5.3.1. Opțiunea name Opțiunea name setează numele graficului. Această opțiune ne va permite, accesând graficul după nume, să poziționăm în dreapta acestuia o casetă informativă cu toate calculele evolventei la fiecare iterație. 5.3.2. Opțiunea trig format=rad Pachetul pgfplots în mode implicit operează cu grade, atunci când avem calcule ce conțin funcții trigonometrice. Pentru proiectarea evolventei vom utiliza radiani. Opțiunea trig format permite reconfigurarea formatului de intrare pentru funcții trigonometrice precum sinus, cosinus, tangentă, etc 8. 5.3.3. Opțiunea axis equal Cu ajutorul opțiunii axis equal, fiecare vector de unitate este setat la aceeași lungime, în timp ce dimensiunile axei rămân constante. După aceea, raporturile de mărime pentru fiecare unitate în x și y vor fi aceleași. Limitele axei vor fi extinse pentru a compensa efectul de scalare 9. 5.3.4. Opțiunea axis lines=center În mod implicit, liniile de axe sunt desenate ca o casetă, însă este posibil de modificat aspectul liniilor axelor x și y. Atribuirea unei valori din cele disponibile, va permite alegerea locației pentru liniile axelor graficului 10. Noi vom seta valoarea center, ceea ce va însemna că axele se vor intersecta în coordonata 0 (origine). 5.3.5. Opțiunea grid=both Această opțiune va desena liniile de grilă pe grafic. 5.3.6. Opțiunile xlabel și ylabel Aceste opțiuni vor desena etichetele axelor graficului, adică textul x și y. Simbolul $ specifică că textul reprezintă o formulă matematică. 5.3.7. Opțiunile xmin, xmax, ymin și ymax Aceste opțiuni permit definirea limitelor axelor, adică colțul din stânga jos și cel din dreapta sus. Tot conținutul ce se va afla în afara acestor limite va fi eliminat 11. 5.3.8. Opțiunile xticklabels și yticklabels Aceste opțiuni permit atribuirea etichetelor pentru fiecare pas a axei (segmente ale axelor). În cazul nostru, nu avem nevoie de etichetele cu numerotarea fiecărui segment al axelor. Pentru aceasta, vom seta la aceste opțiuni valoarea \\empty (gol). ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:5:3","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea și animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"5.4. Adăugarea coordonatelor necesare pe grafic În continuare, vom adăuga 3 coordonate pe grafic, și anume $O$, $L_{\\tiny 1}$ și $L_{\\tiny 2}$. Aceste coordonate ne vor permite să trasăm segmente. Sintaxa de adăugare a coordonatei pe grafic este următoarea: \\coordonate[\u003coptions\u003e] (\u003cname\u003e) at (\u003ccoordonate\u003e); Deci, coordonatele $O$, $L_{\\tiny 1}$ și $L_{\\tiny 2}$ vor fi adaugate astfel: \\coordonate (O) at (0,0); \\coordonate (L1) at ({arcx(\\radius,0,\\rollAngle)},{arcy(\\radius,0,\\rollAngle)}); \\coordonate (L2) at ({involutex(\\radius,\\rollAngle)},{involutey(\\radius,\\rollAngle)}); Segmentul $OL_{\\tiny 1}$ va reprezenta raza cercului, iar unghiul dintre acest segment și segmentul $[0,r]$ va fi însăși unghiul de depanare. Segmentul $L_{\\tiny 1}L_{\\tiny 2}$ va reprezenta tangenta cercului, pornind de la perpendiculară spre punctul maxim al evolventei (calculând valorile ecuațiilor parametrice, unde $\\psi$ va fi egal cu valoarea curentă a variabilei \\rollAngle). coordonatele $O$, $L_1$ și $L_2$ pe grafic. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:5:4","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea și animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"5.5. Proiectarea arcului de cerc rămas după depanare Fiindcă am menționat că evolventa o putem reprezenta ca depanarea aței de pe mosor, atunci la fiecare iterație vom elimina o parte din cerc care corespunde cu unghiul \\rollAngle. Arcul de cerc rămas după depanare. Comanda \\addplot este principala comandă de construire a graficelor, disponibilă în fiecare mediu de axe. Aceasta poate fi folosită de una sau mai multe ori în cadrul axelor pentru a adăuga mai multe grafice 12. Sintaxa de adaugare a graficului pe axe este următoarea: \\addplot[\u003coptions\u003e] \u003cinput data\u003e \u003ctrailing path commands\u003e; Deci, pentru a construi graficul cu arcul de cerc rămas după depanare, vom scrie următoarea comandă: \\addplot [domain=2*pi:\\rollAngle,samples=200,remainingArcColor,thick,line cap=round]({arcx(\\radius,0,x)},{arcy(\\radius,0,x)}); Opțiunile setate la construirea graficului le vom desfășura în continuare, excepție fiind remainingArcColor. Această opțiune doar setează culoarea graficului cu cea declarată în una din secțiunile anterioare. 5.5.1. Opțiunea domain Această opțiune ne permite de a seta domeniul de definiție al funcției. Expresiile graficelor bidimensionale sunt definite ca funcții $f: [x_{\\tiny 1},x_{\\tiny 2}] \\to \\mathbb{R}$ și $\\langle x_{\\tiny 1} \\rangle$ și $\\langle x_{\\tiny 2} \\rangle$ sunt setate cu opțiunea domain 13. În cazul nostru, domeniul de definiție este $f: [2\\pi:\\psi] \\to \\mathbb{R}$, unde $\\psi$ este unghiul curent de depanare, egal cu valoarea variabilei \\rollAngle. Cu alte cuvinte, de la iterație la iterație cercul va pierde o parte din el. Unghiul arcului de cerc eliminat din cerc va corespunde cu valoarea \\rollAngle. 5.5.2. Opțiunea samples Această opțiune setează numărul de puncte de prelevare (sample points) 8. Este de menționat că aceste prelevări se vor conține în domeniul de definiție setat anterior. 5.5.3. Stilul TikZ thick Această stil permite setarea lățimii liniei graficului. Stilul thick, pe care l-am selectat, corespunde cu lățimea de linie 0.8pt 14. TikZ oferă lățimi de linie predefinite, după cum urmează 15: thin ultra thin very thin semithick thick very thick ultra thick 5.5.4. Opțiunea line cap Această opțiune specifică modul în care liniile “se termină”. Tipurile permise sunt round, rect și butt. Acestea au următoarele efecte 16: Tipurile de terminații ale liniilor. Credits: CTAN Pentru reprezentarea grafică a tuturor ecuațiilor parametrice, vom folosi terminații de linii rotunjite, adică vom folosi opțiunea line cap=round. În mod similar, cu aceste opțiuni descrise, vom construi și celelalte grafice. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:5:5","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea și animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"5.6. Proiectarea arcului de cerc depanat Prin comanda de mai jos, vom construi la fiecare iterație un arc de cerc punctat (opțiunea dashedLineColor), care va reprezenta unghiul de depanare al evolventei pe cerc. Acest arc de cerc va avea domeniul de definiție exact invers cu cel anterior, adică $f: [0:\\psi] \\to \\mathbb{R}$. \\addplot [domain=0:\\rollAngle,samples=200,dashedLineColor,dashed,line cap=round]({arcx(\\radius,0,x)},{arcy(\\radius,0,x)}); Ca rezultat, vizual vom avea un singur cerc care de fapt constă din două arcuri de cerc opuse, cu culori și stiluri diferite. Proiectarea arcului de cerc depanat. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:5:6","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea și animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"5.7. Proiectarea evolventei Iată am ajuns și la cel mai important punct. Aici vom construi evolventa propriu-zisă. La construirea acesteia vom folosi ecuațiile parametrice discutate anterior anterior. \\addplot [domain=0.01:\\rollAngle,samples=200,involuteSplineColor,thick,line cap=round]({involutex(\\radius,x)},{involutey(\\radius,x)}); Ca rezultat, obținem profilul evolventei: Profilul evolventei pe grafic. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:5:7","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea și animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"5.8. Proiectarea liniei ce unește tangenta cu capătul evolventei Următorul pas va fi trasarea liniei care unește tangenta cu capătul evolventei. Acest lucru îl vom realiza cu ajutorul comenzii \\draw. Această linie va avea culoarea atribuită în variabila tangentLineColor, lățimea liniei va fi de tip thick și va avea coordonatele L1 și L2 care le-am declarat și inițializat în una din secțiunile precedente. \\draw[tangentLineColor,thick] (L1) -- (L2); Linia aceasta va reprezenta acea “ață”, pe care o depănăm de pe mosor 🧵. Rezultatul arată astfel: Linia ce unește tangenta cu capătul evolventei. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:5:8","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea și animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"5.9. Proiectarea razei cercului Tot cu aceeași sintaxă vom proiecta raza cercului care se va roti odată cu mărirea unghiului de depanare. \\draw[dashedLineColor,dashed] (O) -- (L1) node [accentColor,pos=0.5,sloped,above] {$r$}; Rezultatul îl putem vedea în animația de mai jos, însă opțiunile pe care le-am setat la nod, le vom desfășura în secțiunile următoare. Proiectarea razei cercului. 5.9.1. Opțiunea /tikz/pos Opțiunea /tikz/pos=\u003cfraction\u003e ancorează nodul pe un anumit punct de pe linie de la coordonata anterioară la acea actuală. \u003cfraction\u003e dictează cât de “departe” trebuie să fie punctul pe linie. \u003cfraction\u003e setat ca $0$ reprezintă coordonata anterioară, $1$ este cea curentă, iar toate celelalte valori vor fi între ele. În special, $0.5$ reprezintă mijlocul liniei 17. Noi vom seta valoarea $0.5$, ceea ce va însemna că nodul se afla la mijloc de linie. Același lucru îl putem face cu opțiunea /tikz/midway, care este echivalentul opțiunii pos=0.5. 5.9.2. Opțiunea /tikz/sloped Opțiunea /tikz/sloped face ca nodul să fie rotit, astfel încât linia orizontală a acestuia să devină tangentă cu curba. Rotirea de obicei se face în așa mod, încât textul să nu fie niciodată “cu susul în jos”. 18. Opțiunea /tikz/sloped din pachetul TikZ. Credits: CTAN În cazul nostru avem nu o curbă, ci o linie și textul trebuie să se rotească odată cu rotirea liniei. La momentul când unghiul de depanare va depăși $\\frac{\\pi}{2}$ radiani sau $90^{\\circ}$, această opțiune nu va permite ca textul să fie inversat (cu susul în jos). 5.9.3. Opțiunea /tikz/above Această opțiune este echivalentă cu opțiunea /tikz/anchor=south și permite poziționarea nodului deasupra liniei. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:5:9","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea și animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"5.10. Proiectarea unghiului arcului de cerc depanat La această etapă, vom proiecta unghiul arcului de cerc depanat. Pentru aceasta, vom utiliza comanda \\addplot, sintaxa căreia am desfășurat-o în una din secțiunile anterioare. Unica diferență este că aici adăugăm un nod fix poziționat în punctul $(0.5,-0.3)$ cu textul $\\psi$. \\addplot [domain=0:\\rollAngle,samples=200,accentColor,line cap=round]({arcx(.4,0,x)},{arcy(.4,0,x)}) node[] at (.5, -.3) {$\\psi$}; Desigur că $\\LaTeX$ dispune de o gamă largă de pachete pentru desenarea unghiurilor (cum ar fi pachetul tkz-euclide), însă vom merge pe calea proiectării aceluiași arc de cerc, numai că cu o rază mai mică. Proiectarea unghiului depanării evolventei. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:5:10","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea și animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"5.11. Afișarea parametrilor evolventei la fiecare iterație Parametrii evolventei la fiecare iterație vor fi poziționați într-o casetă, ultima fiind poziționată în dreapta graficului nostru. Afișarea parametrilor evolventei la fiecare iterație. Codul casetei cu parametrii evolventei îl putem vedea mai jos: \\node [xshift=.5cm,below right,align=center,text width=6cm,style=information text] at (plotAxis.north east) { This is a demonstration how the {\\color{accentColor} involute of a circle} works. So, {\\color{accentColor} $r$} is radius of the circle, {\\color{accentColor} $\\psi$} --- roll angle, {\\color{accentColor} $L$} --- arc length and {\\color{accentColor} $k$} -- curvature of the involute. \\begin{align*} {\\color{accentColor} r} \u0026 = const \u0026 \u0026 = \\radius \\\\ {\\color{accentColor} \\psi} \u0026 = \\pgfmathprintnumber[textnumber]{\\rollAngle}\\text{ rad} \u0026 \u0026 \\approx \\pgfmathprintnumber[textnumber]{\\rollAngleDeg}^\\circ \\\\ {\\color{accentColor} L} \u0026 = \\frac{1}{2} \\psi r^2 \u0026 \u0026 = \\pgfmathprintnumber[textnumber]{\\arcLength} \\\\ {\\color{accentColor} \\kappa} \u0026 = \\frac{1}{\\psi r} \u0026 \u0026 \\approx \\pgfmathprintnumber[textnumber]{\\curvature} \\end{align*} }; Această porțiune de cod de la prima vedere pare a fi dificilă. În secțiunile ulterioare vom explica unele momente-cheie ce au loc în acest fragment de cod. 5.11.1. Commanda \\node Nodurile sunt probabil cele mai universale elemente din TikZ. Un nod este de obicei un dreptunghi sau un cerc sau o altă formă simplă cu un text pe el. În cel mai simplu caz, un nod este doar un text care este plasat la o anumită coordonată. \\node[\u003coptions\u003e](\u003cname\u003e) at (\u003ccoordinate\u003e){\u003ctext\u003e}; În cazul nostru, vom crea un nod cu coordonata localizată în colțul drept sus al graficului principal. Acest lucru se realizează prin referirea către numele axei graficului principal, cu indicarea ancorei (punctului de referință a nodului) în poziția nord-est. Ancore poziționate pe caseta de delimitare a axei din pachetul TikZ. Credits: CTAN Opțiunea xshift=.5cm permite de a executa translația casetei pe axa $x$ cu 0.5cm, below right – poziționarea casetei în dreapta sub coordonata setată anterior și cu luarea în considerare a translației efectuate. Opțiunea /tikz/text width=6cm va plasa textul nodului într-o casetă de 6cm lățime. Dacă lățimea textului va depăși această limită, atunci se va întrerupe linia și se va trece conținutul rămas din rând nou. În ceea ce privește opțiunea /tikz/align=center, aceasta este utilizată pentru a configura alinierea textului cu mai multe linii în interiorul unui nod. Dacă opțiunea /tikz/text width este setată la o anumită lățime (să numim această aliniere cu line breaking), opțiunea de aliniere va configura \\leftskip și \\rightskip în așa fel încât textul să fie întrerupt și aliniat în funcție de opțiunea de aliniere 19. Opțiunea style=information text permite de a seta stilul pe care l-am identificat în una din secțiunile anterioare. Această casetă cu parametrii evolventei la fiecare iterație va avea o culoare de fundal roșie cu intensitatea de 10% din culoarea de bază. 5.11.2. Afișarea textului color Pentru afișarea unui text color în nod, putem utiliza sintaxa de mai jos, denumirile culorilor fiind identificate în primele secțiuni. {\\color{accentColor} some text} 5.11.3. Alinierea formulelor matematice din casetă Formulele matematice nu vor fi aliniate într-o formă simplă (stânga, centru, dreapta), ci va avea o formă complexă. Alinierea se va face la simbolul =, cu alte cuvinte toate cele 4 formule se vor poziționa una sub alta cu alinierea strict la acest simbol. Alinierea formulelor matematice după simbolul egal. Acest lucru se face cu ajutorul pachetului amsmath, folosind construcția \\begin{align*} ... \\end{align*} și determinând prin simbolul \u0026 locul unde avem nevoie să aliniem ecuația. \\begin{align*} {\\color{accentColor} r} \u0026 = const \u0026 \u0026 = \\radius \\\\ \\end{align*} Despre semnificația și utilitatea simbolului \u0026 în acest pachet puteți citi aici. ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:5:11","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea și animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"6. Producerea fișierului de ieșire final cu animarea evolventei Dat fiind faptului că lucrăm în devContainer, deja avem toate pachetele instalate pentru convertirea fișierului pdf în mp4 (fișier video cu animarea evolventei). Era posibilă convertirea în fișier gif dar acest format este unul învechit și are o serie de dezavantaje. Există o mulțime de formate mai performante, cum ar fi webp, apng și altele. Nu vom folosi aceste formate, fiindcă problema constă în compatibilitate. Aceste formate nu sunt suportate pe deplin de toate browserele (exemplu pentru apng, webp). Cea mai optimă variantă este mp4. Acest format și codecul H.264 este suportat practic de toate browserele. Putem seta și opțiunea loop pentru repetarea ciclică a video-ului și, astfel, vom obține același efect ca și în cazul unui fișier de tip gif. Prima etapă este convertirea fișierului pdf generat de LaTeX într-o secvență de imagini cu ajutorul pachetului GraphicsMagick. Cu alte cuvinte, fiecare foaie din fișier va fi salvată în imagini distincte cu extensia png. Pentru a realiza această convertire, ne vom folosi de comanda de mai jos, care va salva secvențe de imagini cu densitatea de 300 DPI și fundal alb. mkdir involute-of-circle/output/ gm convert -density 300 involute-of-circle/involute-demo.pdf -background white +adjoin involute-of-circle/output/image_%02d.png # Alternativă folosind pachetul Ghostscript gs -sDEVICE=pngalpha -o involute-of-circle/output/image_%02d.png -r300 involute-of-circle/involute-demo.pdf Următorul pas este convertirea secvenței de imagini în fișier video de tip mp4. Pentru aceasta, ne vom folosi de pachetul preinstalat in container care se numește FFmpeg. ffmpeg -r 15 -i involute-of-circle/output/image_%02d.png -c:v libx264 -vf fps=60 -pix_fmt yuv420p -vf \"pad=ceil(iw/2)*2:ceil(ih/2)*2\" involute-of-circle/output/out.mp4 ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:6:0","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea și animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"7. Concluzie $\\LaTeX$ este un sistem avansat de preparare a documentului. Acesta dispune de un număr larg de pachete care permit realizarea unor sarcini complexe. În acest articol am folosit pachetul PGFPlots (care la rândul său foloseste pachetul TikZ), pentru a proiecta evolventa unui cerc. Animarea evolventei am realizat-o cu ajutorul ciclului foreach, unde la fiecare iterație am modificat unghiul de depanare. Ca rezultat am obținut un fișier pdf cu cadrele necesare pentru animare. Ulterior, acest fișier l-am convertit în fișier mp4 cu ajutorul pachetului GraphicsMagick. Rezultatul final. Experimentând cu evolvente, putem obține astfel de figuri: Experimente cu evolvente. Codul deplin se află pe repository Github. Disclaimer Imaginea reprezentativă a acestui articol conține elemente grafice preluate de pe Freepik (design de către macrovector). What are TEX and its friends? Credits: CTAN ↩︎ Dockerfile reference. Credits: docs.docker.com ↩︎ Standalone: class vs package. StackOverflow ↩︎ Martin Scharrer. The standalone Package, v1.3a din 26.03.2018, p.1. Credits: CTAN ↩︎ Martin Scharrer. The standalone Package, v1.3a din 26.03.2018, p.8. Credits: CTAN ↩︎ Pgfplots package. Credits: Overleaf ↩︎ Parametric equation. Credits: Wikipedia ↩︎ Dr. Christian Feuersänger. Manual for Package pgfplots, v1.17 din 29.02.2020, p.56. Credits: CTAN ↩︎ ↩︎ Dr. Christian Feuersänger. Manual for Package pgfplots, v1.17 din 29.02.2020, p.298. Credits: CTAN ↩︎ Dr. Christian Feuersänger. Manual for Package pgfplots, v1.17 din 29.02.2020, p.270-271. Credits: CTAN ↩︎ Dr. Christian Feuersänger. Manual for Package pgfplots, v1.17 din 29.02.2020, p.327. Credits: CTAN ↩︎ Dr. Christian Feuersänger. Manual for Package pgfplots, v1.17 din 29.02.2020, p.43. Credits: CTAN ↩︎ Dr. Christian Feuersänger. Manual for Package pgfplots, v1.17 din 29.02.2020, p.55. Credits: CTAN ↩︎ LaTeX/PGF/TikZ. Line width. Credits: Wikibooks ↩︎ Dr. Christian Feuersänger. Manual for Package pgfplots, v1.17 din 29.02.2020, p.190. Credits: CTAN ↩︎ Till Tantau și alti autori. TikZ \u0026 PGF. Manual for Version 3.1.5b, v3.1.5b din 08.01.2020, p.175. Credits: CTAN ↩︎ Till Tantau și alti autori. TikZ \u0026 PGF. Manual for Version 3.1.5b, v3.1.5b din 08.01.2020, p.246. Credits: CTAN ↩︎ Till Tantau și alti autori. TikZ \u0026 PGF. Manual for Version 3.1.5b, v3.1.5b din 08.01.2020, p.248. Credits: CTAN ↩︎ Till Tantau și alti autori. TikZ \u0026 PGF. Manual for Version 3.1.5b, v3.1.5b din 08.01.2020, p.235. Credits: CTAN ↩︎ ","date":"2020-08-09","objectID":"/2020/08/latex-involute-of-a-circle/:7:0","tags":["latex","geometry","mathematics","trigonometry","involute","graphicsmagick","imagemagick"],"title":"LaTeX: Proiectarea și animarea evolventei unui cerc","uri":"/2020/08/latex-involute-of-a-circle/"},{"categories":["Proiecte"],"content":"Introducere În acest articol se demonstrează construirea unui Plugin pentru aplicația QGIS 3, ce folosește serviciile Map.md API. Având o experiență modestă în limbajul Python, în acest articol pot fi întâlnite „biciclete inventate“ 😄. Voi fi recunoscător dacă veți oferi sfaturi cum ar fi posibil să îmbunătățesc codul scris. Într-o bună zi, navigând pe rețeaua LinkedIn, am dat de postarea lui Roman Știrbu, CEO al companiei Simpals. În această postare, dumnealui a menționat că a fost lansat serviciul API al sitului Map.md pentru companii care au nevoie de integrare cu CRM sau alte soluții IT. Pentru mine a fost o noutate extraordinară. Operând adesea cu date geospațiale, aveam nevoie de un serviciu similar pentru geocodificarea adreselor. Sigur că la momentul actual existau serviciile Google Geocoding API și OpenStreetMap Nominatim, însă nu eram satisfăcut de rezultatele obținute ale acestor servicii. Aflând de acest serviciu, imediat mi-a venit o idee de a-l implementa în aplicația QGIS, prin construirea unui Plugin 💡. La elaborarea acestuia, m-am inspirat din extensia deja existentă MMQGIS. Printre multiplele funcționalități ce le are, acesta dispune și de geocodificarea adreselor prin intermediul serviciilor menționate anterior. ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:1:0","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Crearea șablonului extensiei QGIS (QGIS Plugin) Pentru a crea șablonul extensiei QGIS, este nevoie de aplicația propriu-zisă instalată în calculator și de extensiile Plugin Builder 3, debugvs și Plugin Reloader. ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:2:0","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Generarea șablonului cu ajutorul extensiei Plugin Builder 3 La pornirea acestei aplicații navigăm meniul Plugins ► Plugin Builder ► Plugin Builder. După afișarea dialogului, completăm forma cu detaliile referitoare la extensie. Apăsând butonul next, introducem informația detailată privind extensia QGIS, șablonul căreia urmează a fi creat. În următoarea formă, alegem șablonul Tool button with dialog, meniul Plugins și numele elementului meniului, spre exemplu, MapMD. Sărind la următorul pas, selectăm toate opțiunile, pentru a avea o funcționalitate mai vastă a extensiei. La următorul pas, suplinim forma privind publicarea extensiei. Pentru aceasta, eu am creat prealabil un repository pe Github și am introdus datele indicate în imaginea de mai jos. Plus la aceasta, am marcat extensia dată ca experimentală, deoarece aceasta se va afla la starea de development și va fi instabilă la început. La ultimul pas, alegem mapa unde va fi generat proiectul și apăsăm butonul Generate. ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:2:1","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Note suplimentare privind procesul de generare al șablonului extensiei Notă: Pentru a putea face development și debugging este necesar ca proiectul cu extensie să fie localizat aici: %APPDATA%\\QGIS\\QGIS3\\profiles\\default\\python\\plugins\\map_md_geocoding În caz că se afișează avertizare The resource compiler pyrccc5 was not found in your path, omitem și primim o instrucție cu pașii ulteriori pentru a avea posibilitatea dezvolta cu succes extensia. ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:2:2","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Configurarea mediului de dezvoltare al extensiei Pentru dezvoltarea extensiei, este nevoie de configurat mediul de dezvoltare. În acest scop, folosesc sistemul de operare Windows 10 și editorul Visual Studio Code. ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:3:0","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Pregătirea mediului de dezvoltare În mapa cu extensia dată creăm un fișier cu denumirea start_vscode.cmd și scrim instrucțiunile de mai jos. De fiecare dată când va fi necesar de dezvoltat extensia, vom rula acest fișier. Acest fișier setează variabilele de mediu necesare pentru dezvoltarea și debugging-ul extensiei și, ulterior, lansează editorul VS Code. @echo off SET OSGEO4W_ROOT=C:\\OSGeo4W64 call \"%OSGEO4W_ROOT%\"\\bin\\o4w_env.bat call \"%OSGEO4W_ROOT%\"\\bin\\qt5_env.bat call \"%OSGEO4W_ROOT%\"\\bin\\py3_env.bat path %PATH%;%OSGEO4W_ROOT%\\apps\\qgis\\bin path %PATH%;%OSGEO4W_ROOT%\\apps\\Qt5\\bin path %PATH%;%OSGEO4W_ROOT%\\apps\\Python37\\Scripts path %PATH%;C:\\Program Files\\7-Zip path %PATH%;C:\\Program Files\\Git\\cmd set PYTHONPATH=%PYTHONPATH%;%OSGEO4W_ROOT%\\apps\\qgis\\python\\ set PYTHONPATH=%PYTHONPATH%;%OSGEO4W_ROOT%\\apps\\qgis\\python\\qgis set PYTHONPATH=%PYTHONPATH%;%OSGEO4W_ROOT%\\apps\\qgis\\python\\qgis\\PyQt5 set PYTHONPATH=%PYTHONPATH%;%OSGEO4W_ROOT%\\apps\\qgis\\python\\qgis\\core set PYTHONHOME=%OSGEO4W_ROOT%\\apps\\Python37 start \"VS Code with PyQGIS and OsGeo4W\" /B \"%LOCALAPPDATA%\\Programs\\Microsoft VS Code\\Code.exe\" . În VS Code, creăm un nou fișier în mapa generată a extensiei cu denumirea requirements.txt și introducem în el pachetele necesare pentru instalare în mediul virtual: autopep8 pb_tool ptvsd sphinx_rtd_theme Ulterior, instalăm aceste pachete, efectuând următoarea instrucțiune: pip install -r requirements.txt Având pachetele necesare instalate, compilăm resursele aplicației prin efectuarea instrucțiunii de mai jos. Aceasta va genera fișierul resources.py. pb_tool compile ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:3:1","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Verificarea funcționalității extensiei Pentru a verifica dacă totul funcționează bine, lansăm proiectul prin executarea instrucțiunii de mai jos. Aceasta trebuie sa compileze proiectul și să-l copie în mapa cu extensiile QGIS. pb_tool deploy După, pornim aplicația QGIS și activăm extensia noastră prin navigarea meniului Plugins ► Manage and Install Plugins... ► Installed ► MapMD. Ulterior, pornim extensia creată prin apăsarea butonului corespunzător de pe bara de instrumente. ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:3:2","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Ajustarea interfeței extensiei Pentru a adăuga elemente în interfața extensiei, este necesar de a rula aplicația Qt Designer. Aceasta o găsiți pe următoarea cale C:\\OSGeo4W64\\bin\\qgis-designer.bat. Apoi, deschideți cu ajutorul acestei aplicații fișierul map_md_dialog_base.ui ce se află în mapa cu proiectul extensiei, adăugați componentele necesare și salvați fișierul, ca urmare fereastra să arate în felul următor: ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:4:0","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Crearea clasei destinată procesului de geocodificare Pentru a implementa funcționalitățile extensiei, metodele ulterioare le-am inclus într-o clasă distinctă care va fi moștenită de la clasa QgsTask. Această clasă permite ca procesul de geocodificare să fie adăugat în managerul de sarcini al aplicației QGIS, cu alte cuvinte extensia nu va bloca interfața aplicației geospațiale și procesul de geocodificare va putea fi întrerupt la cererea utilizatorul, ca rezultat afișându-se numai adresele geocodificare până la această întrerupere. În această clasă am importat bibliotecile necesare și am declarat variabilele cu care voi opera pe parcurs, denumirea celor private începându-se cu două simboluri underscore („_”). Constructorul clasei conține argumente cu valori implicite care sunt opționale. import csv import codecs import sqlite3 import urllib.parse import re import requests import shapely from shapely.geometry import shape # pylint: disable=import-error from qgis.utils import iface from qgis.core import (QgsDataSourceUri, Qgis, QgsTask, QgsMessageLog) # pylint: enable=import-error # Clasa moștenită de la clasa QgsTask, # ce permite adăugarea sarcinii de geocodificare în # managerul de sarcini al aplicației Qgis. class MapMdUtils(QgsTask): def __init__(self, input_filename, output_filename=\"\", notfound_filename=\"\", api_key=\"\", street1_index=-1, street2_index=-1, house_number_index=-1, locality_index=-1): # Se apelează constructorul clasei QgsTask, # unde se introduce denumirea sarcinii și abilitatea de a # întrerupe procesul de geocodificare. super().__init__(\"Geocodificarea adreselor\", QgsTask.CanCancel) self.__api_key = api_key # Cheia API self.__street1_index = street1_index # Indicele coloanei Strada1 self.__street2_index = street2_index # Indicele coloanei Strada2 self.__house_number_index = house_number_index # Indicele coloanei numărul casei self.__locality_index = locality_index # Indicele coloanei Localitate self.__input_filename = input_filename # Calea spre fișierul de intrare self.__output_filename = output_filename # Calea spre fișierul de ieșire self.__notfound_filename = notfound_filename # Calea spre fișierul cu adrese neidentificate self.__table_name = \"point_geometry\" # Denumirea tabelului SpatiaLite (SQLite) self.__header = [self.__quote_identifier( item) for item in next(self.read_csv())] # Denumirile coloanelor self.__not_found_count = 0 # Cantitatea adreselor neidentificate self.exception = None # Excepția returnată în urma geocodificării ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:5:0","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Lucrul cu fișierul de intrare și cel ce conține adrese neidentificate ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:6:0","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Citirea fișierului de intrare Pentru citirea fișierului de intrare, care trebuie să fie de tip CSV cu codificarea UTF-8, eu am creat o metodă care va citi rând cu rând acest fișier, iar în caz că va surveni o excepție, aceasta va fi afișată în bara de mesaje ale aplicației geospațiale QGIS. def read_csv(self): \"\"\" Read CSV file. \"\"\" try: with open(self.__input_filename, 'r', encoding='utf-8') as csvfile: # Identify CSV dialect (delimiter) dialect = csv.Sniffer().sniff(csvfile.read(4096)) csvfile.seek(0) reader = csv.reader(csvfile, dialect) for row in reader: yield row except IOError: iface.messageBar().pushCritical( \"Input CSV File\", \"Failure opening \" + self.__input_filename) except UnicodeDecodeError: iface.messageBar().pushCritical( \"Input CSV File\", \"Bad CSV file - Unicode decode error\") except csv.Error: iface.messageBar().pushCritical( \"Input CSV File\", \"Bad CSV file - verify that your delimiters are consistent\") ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:6:1","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Calcularea numărului de rânduri ale fișierului de intrare Pentru ca în aplicația QGIS să fie afișat procentajul de îndeplinirii a sarcinii de geocodificare, eu am creat o metodă pentru calcularea numărului de rânduri ale fișierului de intrare de tip CSV. def __count_csv_lines(self): \"\"\" Count CSV lines. \"\"\" try: with open(self.__input_filename, 'r', encoding='utf-8') as csvfile: return sum(1 for row in csvfile) except csv.Error: iface.messageBar().pushCritical( \"Input CSV File\", \"Bad CSV file - verify that your delimiters are consistent\") ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:6:2","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Scrierea rândurilor cu adrese neidentificate în fișier CSV În caz că adresele indicate în fișierul de intrare nu au fost posibil de geocodificat, extensia dată copie întregul rând ce conține adresa neidentificată în fișierul de ieșire care, la fel, reprezintă un fișier CSV cu codificarea UTF-8 și incrementează numărul de adrese neidentificate care la final de process va fi afișat în aplicația QGIS. def __write_notfound_street_to_csv(self, row): \"\"\" Write not found street to CSV file. param line: Line to be written in CSV file. type line: str \"\"\" with open(self.__notfound_filename, mode='a', newline='') as csvfile: csv_writter = csv.writer( csvfile, delimiter=',', quotechar='\"', quoting=csv.QUOTE_MINIMAL) csv_writter.writerow(row) self.__not_found_count += 1 # Increment pentru cantitatea adreselor neidentificate # Se expediază către aplicația QGIS log că adresa nu a fost identificată. QgsMessageLog.logMessage( \"Nu a fost geocodificat rândul CSV: %s\" % ','.join(row), level=Qgis.Warning) ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:6:3","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Utilizarea serviciului API Geocodificare al site-ului Map.md Pentru a utiliza serviciul API Geocodificare al site-ului Map.md API, este nevoie de a obține cheia API 🔑. ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:7:0","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Obținerea cheii API Pentru a utiliza serviciul API Geocodificare, este necesar de obținut un cod unic de identificare. Pentru aceasta, este necesar să ne conectăm la sistemul Simpals-ID, utilizând login-ul sau parola contului pentru oricare dintre proiectele companiei. Apoi, accesăm link-ul map.md/ro/api, facem click pe butonul Obțineți codul, completăm formularul special și salvăm codul rezultat. Informația detailată privind obținerea cheii API o puteți găsi în acest articol. ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:7:1","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Implementarea metodelor destinate adresării către Map.md API Pentru a geocodifica adresele conținute în fișierul de intrare, eu am realizat 3 metode care vor răspunde de: căutarea și obținerea identificatorului străzii; obținerea datelor geospațiale ale străzii; și obținerea datelor geospațiale ale străzii cu numărul casei indicat. def __map_md_search_street(self, row, street): \"\"\" Map.md search street method. param row: Row list. type row: list of str param street: Street. type street: str :return: False or JSON :rtype: dict of str \"\"\" # Se obține denumirea localității din rândul CSV. locality = row[self.__locality_index] # Se face cerere către Map.md API, pentru a obține # identificatorul străzii. r = requests.get( \"https://map.md/api/companies/webmap/search_street?\" + \"location=%s\u0026q=%s\" % (urllib.parse.quote(locality), urllib.parse.quote(street)), auth=(self.__api_key, \"\")) # Dacă nu a fost găsită strada sau a fost returnată o eroare, # rândul se scrie în fișierul cu adrese neidentificate și # metoda returnează False. if not r or not r.json(): self.__write_notfound_street_to_csv(row) return False return r.json() def __map_md_get_street(self, street_id, row): \"\"\" Map.md get street method. param street_id: The Map.md street id. type street_id: int param row: Row list. type row: list of str :return: False or JSON :rtype: dict of str \"\"\" # Se obține denumirea localității din rândul CSV. locality = row[self.__locality_index] # Se face cerere către Map.md API, pentru a obține datele # geospațiale ale străzii. r = requests.get( \"https://map.md/api/companies/webmap/get_street?\" + \"id=%s\u0026location=%s\" % (urllib.parse.quote(street_id), urllib.parse.quote(locality)), auth=(self.__api_key, \"\")) # Dacă nu a fost găsită strada sau a fost returnată o eroare, # rândul se scrie în fișierul cu adrese neidentificate și # metoda returnează False. if not r or not r.json(): self.__write_notfound_street_to_csv(row) return False return r.json() def __map_md_search_street_with_house_number(self, row, street_id, house_number): \"\"\" Map.md search street with house number method. param row: Row list. type row: list of str param house_number: House number. type house_number: str :return: False or JSON :rtype: dict of str \"\"\" # Se face cerere către Map.md API, pentru a obține datele # geospațiale ale străzii și numărului casei. r = requests.get( \"https://map.md/api/companies/webmap/get_street?\" + \"id=%s\u0026number=%s\" % (urllib.parse.quote(street_id), urllib.parse.quote(house_number)), auth=(self.__api_key, \"\")) # Dacă nu a fost găsită strada și numărul casei sau a fost # returnată o eroare, rândul se scrie în fișierul cu adrese # neidentificate și metoda returnează False. if not r or not r.json(): self.__write_notfound_street_to_csv(row) return False return r.json() ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:7:2","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Utilizarea bazei de date SpatiaLite pentru stocarea adreselor geocodificate ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:8:0","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"De ce SpatiaLite Extensia MMQGIS, care a servit drept sursă de inspirație, salvează adresele geocodificate într-un fișier (ba chiar în mai multe 😏) cu extensia ShapeFile (*.shp). Această metodă de a salva adresele geocodificate nu este favorabilă deoarece acest tip de fișier are următoarele limite și dezavantaje: Lungimea denumirii coloanelor nu poate depăși 10 caractere; Suport slab a codificării Unicode; Pe lângă fișierul cu extensia_.shp_, în aceeași mapă se mai stochează și alte fișiere cu diverse extensii (_.dbf_, *.prj, *.qpj, *.shx, etc.). Operând adesea cu date geospațiale, în ultimul timp le salvam, prin intermediul aplicației QGIS, în baze de date de tip SpatiaLite, care reprezintă nu altceva, decât baze de date de tip SQLite cu date geospațiale. Aplicația QGIS permite de a manipula aceste baze de date, salvând o mulțime de straturi ale aplicației într-un singur fișier. Super! E ceea de ce am nevoie! 🤗 Problema consta în aceea, că cu baze de date de tip SQL reușisem să operez la un nivel superficial, însă nu aveam idee cum să proiectez baze de date de tip SpatiaLite. Navigând pe Internet am găsit următoarea serie de articole care explică clar cum funcționează această bază de date. Minunat! E timpul pentru experimente 🧪💡. ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:8:1","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Structura bazei de date SpatiaLite Baza de date de tip SpatiaLite trebuie să conțină un tabel destinat pentru salvarea datelor geospațiale 🌍. Baza de date și tabelul vor fi create la începutul geocodificării adreselor, adăugându-se coloanele tabelului în strictă corespundere cu coloanele din fișierul de intrare de tip CSV. Ulterior, se mai adaugă o coloană ce conține date geospațiale, în cazul dat, de tip Point cu geoproiecția WGS84 (4326) 🌏. La final, este necesar de creat index pentru cheia primară și pentru coloana cu date geospațiale, pentru a îmbunătăți performanța bazei de date 📈. ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:8:2","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Proiectarea bazei de date SpatiaLite Modalitatea de inițiere a bazei de date, creării tabelului pentru adrese geocodificate și a index-urilor este indicată în metoda de mai jos. def __init_spatialite_db(self): \"\"\" Init SpatiaLite database.\"\"\" with sqlite3.connect(self.__output_filename) as conn: conn.enable_load_extension(True) conn.load_extension(\"mod_spatialite\") conn.execute(\"SELECT InitSpatialMetaData(1);\") conn.execute(\"\"\"CREATE TABLE IF NOT EXISTS %s ( PointId INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT);\"\"\" % self.__table_name) conn.execute(\"\"\"CREATE UNIQUE INDEX IF NOT EXISTS idx_%s_id ON %s (PointId);\"\"\" % (self.__table_name, self.__table_name)) cur = conn.cursor() cur.execute(\"PRAGMA table_info('%s');\" % self.__table_name) db_columns = cur.fetchall() db_columns = (x[1] for x in db_columns) db_columns = [self.__quote_identifier(x) for x in db_columns] for column in self.__header: # Se adauga coloanele care nu au existat anterior if column not in db_columns: conn.execute(\"\"\"ALTER TABLE %s ADD COLUMN %s TEXT\"\"\" % (self.__table_name, column)) # Se adauga coloana ce contine date geospatiale # cu geoproiectia WSG 84 (4326) if \"Geometry\" not in db_columns: conn.execute( \"\"\"SELECT AddGeometryColumn( 'point_geometry', 'Geometry', 4326, 'POINT', 'XY');\"\"\") # Se adauga index geospatial conn.execute( \"SELECT CreateSpatialIndex('point_geometry', 'Geometry');\") În fragmentul de cod ce urmează, este realizată funcționalitatea de adăugare a rândului CSV, ce a fost geocodificat cu succes, în tabelul bazei de date SpatiaLite și adăugarea coordinatelor punctului unde este localizată adresa sau intersecția. def __add_row_to_db(self, row, geometry): \"\"\" Add CSV row to database. param csv_row: CSV row. type csv_row: list of str param geometry: Point geometry. type geometry: str \"\"\" with sqlite3.connect(self.__output_filename) as conn: conn.enable_load_extension(True) conn.load_extension(\"mod_spatialite\") cur = conn.cursor() # Insert it. sql = \"\"\"INSERT INTO point_geometry (%s, Geometry) VALUES (%s, GeomFromText('%s', 4326));\"\"\" % \\ ( ','.join(self.__header), ','.join([self.__quote_identifier(item) for item in row]), geometry ) cur.execute(sql) ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:8:3","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Implementarea procesului de geocodificare propriu-zis Extensia pe care am creato va implementa 4 tipuri de geocodificări, după cum urmează: Geocodificarea străzii, numărului casei și localității; Geocodificarea străzii și localității, când numărul casei se conține în câmpul cu stradă; Geocodificarea intersecțiilor (strada1, strada2, localitate); Geocodificarea combinată (se alege una din cele menționate mai sus, în dependență de ce câmpuri în fișierul CSV sunt suplinite). ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:9:0","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Implementarea metodelor de geocodificare a rândurilor CSV În următoarele fragmente de cod, eu am implementat 2 metode ce vor geocodifica strada și numărul casei și, respectiv, intersecția a două străzi. Aceste metode vor apela la metodele create anterior care comunică cu serviciul API Geocodificare al site-ului Map.md. def __geocode_street_and_house_number(self, row, street, house_number): \"\"\" Geocode street1 and house number. param row: Row list. type row: list of str param street: Street. type street: str param house_number: House number. type house_number: str :return: Return bool. :rtype: bool \"\"\" r = self.__map_md_search_street(row, street) if not r: return False # Se obtine lista cu numerele caselor adresei solicitate buildings = r[0]['buildings'] # Daca numarul casei nu se gaseste in lista, # nu se indeplineste cel de-al doilea request if house_number not in buildings: self.__write_notfound_street_to_csv(row) return False r = self.__map_md_search_street_with_house_number( row, r[0]['id'], house_number) if not r: return False geometry = \"POINT(%s %s)\" % (r['point']['lon'], r['point']['lat']) self.__add_row_to_db(row, geometry) def __geocode_street1_and_street2(self, row, street1, street2): \"\"\" Geocode street1 and street2. param row: Row list. type row: list of str param street: Street1. type street: str param street: Street2. type street: str :return: Return bool. :rtype: bool \"\"\" # Se cauta strada1 pentru a obtine identificatorul ei r1 = self.__map_md_search_street(row, street1) # Se cauta strada2 pentru a obtine identificatorul ei r2 = self.__map_md_search_street(row, street2) # Verificare strada1 si strada2 if not r1 or not r2: return False # Se obtine datele despre strada1 si strada2 r1 = self.__map_md_get_street(r1[0]['id'], row) r2 = self.__map_md_get_street(r2[0]['id'], row) if not r1 or not r2: return False r1_geo_json = r1['geo_json'] r2_geo_json = r2['geo_json'] s1 = shape(r1_geo_json) s2 = shape(r2_geo_json) if not s1.intersects(s2): self.__write_notfound_street_to_csv(row) return False geometry = s1.intersection(s2) # In cazul ca se identifica MultiPoint, # se ia primul Point in consideratie if isinstance(geometry, shapely.geometry.multipoint.MultiPoint): geometry = geometry[0] self.__add_row_to_db(row, geometry.wkt) ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:9:1","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Implementarea metodei de rulare a procesului de geocodificare Pentru a rula procesul de geocodificare, instrucțiunile destinate acestui scop au fost plasate în metoda run, din motiv că managerul de sarcini al aplicației QGIS apelează anume această metodă când se adaugă o sarcină nouă în acesta (metoda addTask). def run(self): \"\"\" Geocode addresses using Map.md API. return: Return bool type. type: bool \"\"\" QgsMessageLog.logMessage(\"Început geocodificare.\", level=Qgis.Info) # Se initializeaza baza de date SpatiaLite self.__init_spatialite_db() pattern = r\"^((?:[a-z0-9ăîșțâ]+[\\., ]+)+)(\\d{1,3}(?:[\\/ ]?\\w{1,2})?)$\" if self.__street1_index == -1 and self.__locality_index == -1: self.exception = Exception( \"Indicele câmpurilor street1 și/sau locality sunt goale!\") # Se omite primul rand, deoarece contine denumirile coloanelor iter_rows = iter(self.read_csv()) next(iter_rows) for index, row in enumerate(iter_rows): self.setProgress(index*100/self.__count_csv_lines()) # verifică isCanceled() pentru a gestiona anularea geocodificării if self.isCanceled(): return False if not row[self.__street1_index] and \\ not row[self.__locality_index]: self.__write_notfound_street_to_csv(row) elif self.__street2_index \u003e -1 and \\ row[self.__street2_index]: QgsMessageLog.\\ logMessage(\"Street1 + Street2 + Locality\", level=Qgis.Info) geocode_street1_and_street2 = \\ self.__geocode_street1_and_street2( row, row[self.__street1_index], row[self.__street2_index]) if not geocode_street1_and_street2: continue elif self.__house_number_index \u003e -1 and \\ row[self.__house_number_index]: QgsMessageLog.\\ logMessage(\"Street1 + House number + Locality\", level=Qgis.Info) geocode_street_and_house_number = \\ self.__geocode_street_and_house_number( row, row[self.__street1_index], row[self.__house_number_index]) if not geocode_street_and_house_number: continue else: QgsMessageLog.logMessage(\"Street1 + Locality\", level=Qgis.Info) match = re.search(pattern, row[self.__street1_index], re.IGNORECASE | re.UNICODE) if not match: self.__write_notfound_street_to_csv(row) continue street = match.group(1).replace(',', '').strip() house_number = match.group(2).strip() geocode_street_and_house_number = \\ self.__geocode_street_and_house_number( row, street, house_number) if not geocode_street_and_house_number: continue return True ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:9:2","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Implementarea metodei de finisare a procesului de geocodificare Clasa QgsTask mai implementează o metodă denumită finished, care va fi apelată după finalizarea sarcinii (fie prin finalizare cu succes, fie prin anulare la cererea utilizatorului). Argumentul result reflectă dacă sarcina a fost finalizată cu succes sau nu. Această metodă este întotdeauna apelată de la thread-ul principal, deci se permite de a adăuga stratul cu puncte geocodificate în aplicație. def finished(self, result): \"\"\" This function is automatically called when the task has completed (successfully or not). You implement finished() to do whatever follow-up stuff should happen after the task is complete. finished is always called from the main thread, so it's safe to do GUI operations and raise Python exceptions here. result is the return value from self.run. \"\"\" if result: # Se adauga stratul in QGIS self.__add_spatialite_layer_to_qgis() csv_row_count = self.__count_csv_lines() QgsMessageLog.logMessage( \"Sfârșit geocodificare.\" + \"Au fost geocodificate %i din %i adrese.\" % (csv_row_count-self.__not_found_count, csv_row_count), level=Qgis.Success) elif self.exception is None: # Se adauga stratul in QGIS self.__add_spatialite_layer_to_qgis() QgsMessageLog.logMessage( \"Geocodificarea a fost anulată. \" + \"Se afișează rezultatele obținute până la moment.\", level=Qgis.Warning) else: QgsMessageLog.logMessage( \"Procesul de geocodificare a returnat o excepție:\\n%s\" % str(self.exception), level=Qgis.Critical) raise self.exception ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:9:3","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Implementarea logicii pentru interfața dialogul de geocodificare Interfața dialogului extensiei creată anterior este lipsită de un oarecare funcțional, cu alte cuvinte nu implementează nici-o logică. E timpul să reparăm acest lucru 🤗. ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:10:0","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Importarea bibliotecilor necesare În primul rând, ne asigurăm că am importat tot de ce vom avea nevoie pe parcurs: import os from PyQt5 import uic from PyQt5 import QtWidgets from PyQt5.QtWidgets import QFileDialog, QDialogButtonBox from .map_md_utils import MapMdUtils ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:10:1","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Asigurarea conexiunii evenimentelor cu metodele respective Ulterior, la constructorul clasei MapMdDialog, implementăm conexiunile evenimentelor de modificare a textului, de apăsare click pe butoane cu metodele corespunzătoare. self.button_box.button(QDialogButtonBox.Ok).setEnabled(False) # Conectăm evenimentele de modificare a textului cu metoda ce va # activa butonul OK. self.input_filename.textChanged.connect(self.is_ready_to_geocode) self.output_spatialite_filename.textChanged.connect(self.is_ready_to_geocode) self.output_notfound_filename.textChanged.connect(self.is_ready_to_geocode) self.api_key.textChanged.connect(self.is_ready_to_geocode) self.street_field1.currentTextChanged.connect(self.is_ready_to_geocode) self.locality_field.currentTextChanged.connect(self.is_ready_to_geocode) # Conectarea evenimentelor click pe butoane cu metodele ce vor # afișa dialoguri de deschidere/salvare a fișierelor. self.browse_infile.clicked.connect(self.browse_infile_dialog) self.browse_spatialite.clicked.connect(self.browse_spatialite_file_dialog) self.browse_notfound.clicked.connect(self.browse_notfound_file_dialog) ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:10:2","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Implementarea metodei de alegere a fișierului de intrare În fragmentul de cod ce urmează, este implementat funcționalul de alegere a fișierului de intrare de tip CSV UTF-8. Pentru aceasta, după apăsarea click pe primul buton Browse…, se va afișa dialogul de deschidere a fișierului. După alegerea fișierului de intrare, în câmpul fișierului de ieșire se va salva calea absolută a fișierului de intrare, aceeași denumire ca și fișierul de intrare + extensia .db, iar în câmpul fișierului cu adrese neidentificate – calea absolută a fișierului de intrare cu denumirea fișierului notfound.csv. După aceasta, toate elementele combobox vor fi suplinite cu denumirile coloanelor fișierului de intrare, pentru a permite utilizatorului de a asocia câmpurile extensiei cu coloanele din fișierul de intrare. def browse_infile_dialog(self): \"\"\" Browse input CSV file dialog \"\"\" input_file_name, _ = QFileDialog.getOpenFileName( None, \"Address CSV Input File\", self.input_filename.displayText(), \"CSV File (*.csv *.txt)\") if input_file_name and len(input_file_name) \u003e 4: abspath = os.path.abspath(input_file_name) # Se seteaza calea fisierului de intrare self.input_filename.setText(abspath) # Se seteaza calea spre fisierul de iesire (SpatiaLite) # Se inlocuieste extensia '.csv' cu '.db' self.output_spatialite_filename.setText( os.path.join( os.path.dirname(abspath), os.path.splitext( os.path.basename(abspath))[0] + '.db')) # Se seteaza calea spre fisierul CSV cu adrese neidentificate self.output_notfound_filename.setText( os.path.join(os.path.dirname(abspath), 'notfound.csv')) combolist = [self.street_field1, self.street_field2, self.house_number_field, self.locality_field] for box in combolist: box.clear() box.addItem(\"(none)\") box.setCurrentIndex(0) map_md_utils = MapMdUtils( self.input_filename.displayText()) try: header = next(map_md_utils.read_csv()) header = [field for field in header] if header is None: return for index in header: for box in combolist: box.addItem(index) except StopIteration: pass ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:10:3","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Implementarea metodei de alegere a căilor spre fișierele de ieșire Cum am menționat anterior, după alegerea fișierului de intrare, în mod implicit se modifică și calea spre fișierele de ieșire și a celui ce conține adrese neidentificate, însă aceste căi (precum și denumirea fișierelor) pot fi modificate la cererea utilizatorului, apăsând pe butoanele Browse… în drept cu câmpurile menționate. def browse_spatialite_file_dialog(self): \"\"\" Browse SpatiaLite file dialog. \"\"\" output_file_name, _ = QFileDialog.getSaveFileName( None, \"Output SpatiaLite File\", self.output_spatialite_filename.displayText(), \"SpatiaLite File (*.db *.sqlite)\") if output_file_name: self.output_spatialite_filename.setText( os.path.abspath(output_file_name)) def browse_notfound_file_dialog(self): \"\"\" Browse Not Found file dialog. \"\"\" output_file_name, _ = QFileDialog.getSaveFileName( None, \"Output Not Found File\", self.output_notfound_filename.displayText(), \"CSV File (*.csv *.txt)\") if output_file_name: self.output_notfound_filename.setText( os.path.abspath(output_file_name)) ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:10:4","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Verificarea disponibilității procedurii de geocodificare Câmpul cu calea spre fișierul de intrare să nu fie gol; Câmpul cu calea spre fișierul de ieșire să nu fie gol; Câmpul cu cheia API să nu fie gol; Componentul combobox cu denumirea Street 1 field să nu fie gol; Componentul combobox cu denumirea Locality field să nu fie gol. După satisfacerea acestor condiții, butonul OK al interfeței dialogului extensiei va fi pornit și va fi posibil de apăsat. def is_ready_to_geocode(self): \"\"\" Enable or disable OK button whether all required field are filled. \"\"\" is_ready = self.input_filename.displayText() \\ and self.output_spatialite_filename.displayText() \\ and self.output_notfound_filename.displayText() \\ and self.api_key.displayText() \\ and self.street_field1.currentIndex() \u003e 0 \\ and self.locality_field.currentIndex() \u003e 0 self.button_box.button(QDialogButtonBox.Ok).setEnabled( bool(is_ready)) ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:10:5","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Modificarea fișierului principal al extensiei În fișierul map_md.py ne asigurăm că am importat următoarele biblioteci: import os.path from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication from PyQt5.QtGui import QIcon from PyQt5.QtWidgets import QAction from qgis.core import QgsApplication, QgsMessageLog from .resources import * from .map_md_dialog import MapMdDialog from .map_md_utils import MapMdUtils ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:11:0","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Obținerea datelor din interfața dialogului extensiei și adăugarea procesului de geocodificare în managerul de sarcini În constructorul clasei MapMd, atribuim o variabilă care va obține obiectul managerului de sarcini al aplicației QGIS. self.task_manager = QgsApplication.taskManager() Ulterior, dacă a fost apăsat butonul OK din interfața dialogului extensiei, atunci se obține toți parametrii setați în aceasta, se crează o nouă instanță a clasei MapMdUtils, care extinde clasa QgsTask și o transmite metodei addTask a obiectului taskManager. if result: # Init variables api_key = self.dlg.api_key.displayText() street1_index = self.dlg.street_field1.currentIndex() - 1 street2_index = self.dlg.street_field2.currentIndex() - 1 house_number_index = self.dlg.house_number_field.currentIndex() - 1 locality_index = self.dlg.locality_field.currentIndex() - 1 input_filename = self.dlg.input_filename.displayText() output_filename = self.dlg.output_spatialite_filename.displayText() notfound_filename = self.dlg.output_notfound_filename.displayText() map_md_utils = MapMdUtils(input_filename, output_filename, notfound_filename, api_key, street1_index, street2_index, house_number_index, locality_index, ) # Geocoding CSV rows task_id = self.task_manager.addTask(map_md_utils) QgsMessageLog.logMessage(\"Atribuită sarcină nr. %s\" % str(task_id)) ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:11:1","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"},{"categories":["Proiecte"],"content":"Încheire La primele testări, această extensie funcționează bine. Extensia o puteți găsi pe depozitul Plugin-urilor QGIS sau pe repository oficial Github ","date":"2019-08-04","objectID":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/:12:0","tags":["pyqgis","pyqt5","python","qgis"],"title":"QGIS Plugin: Implementarea serviciului Map.md API","uri":"/2019/08/qgis-plugin-implementarea-serviciului-map-md-api/"}]